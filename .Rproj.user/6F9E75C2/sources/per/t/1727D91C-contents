{# ============================
  # TRI-FX-ARB — DEMO / SHOWCASE
  # (med pretty console, forced candidate, live 3-legs, tydelige µs-tider + leg-trace)
  # TUNED FOR MINIMAL SLEEP/DELAY — all per-leg sleeps set to 0
  # ============================
  
  # --- Globale småinnstillinger helt i toppen ---
  options(stringsAsFactors = FALSE)  # ryddigere utskrifter på eldre R
  
  # Små hjelpere (tilgjengelig overalt)
  `%||%` <- function(x, y) if (is.null(x)) y else x
  
  # NA-robuste formaterere (tall / mikrosekunder)
  fmt_us <- function(x) {
    xv <- suppressWarnings(as.numeric(x))
    if (is.finite(xv)) paste(formatC(as.integer(round(xv)), format = "d", big.mark = " "), "\u00B5s") else "NA \u00B5s"
  }
  fmt_num <- function(x, digits = 6) {
    xv <- suppressWarnings(as.numeric(x))
    ifelse(is.finite(xv), format(round(xv, digits), nsmall = digits, big.mark = " "), "NA")
  }
  
  suppressPackageStartupMessages({ library(Rcpp); library(jsonlite) })
  
  # --- C++ engine først ---
  Rcpp::sourceCpp(file.path(ROOT, "R", "Ccomputing.cpp"))
  Rcpp::sourceCpp(file.path(ROOT, "Backupfiler", "traderhelperC.cpp"))    # ← NY (dine preselect/tri_pnl_batch m.m.)
  
  # --- Core R files ---
  source(file.path(ROOT, "R", "DS.R"))
  source(file.path(ROOT, "R", "utils.R"))
  source(file.path(ROOT, "Backupfiler", "tradingrobot copy.R"))
  source(file.path(ROOT, "R", "Engine_Wrappers.R"))
  source(file.path(ROOT, "R", "core_runtime.R"))
  suppressWarnings({ if (file.exists(file.path(ROOT, "R", "Dev_utils.R"))) source(file.path(ROOT, "R", "Dev_utils.R")) })
  
  
  # ============================
  # PRETTY CONSOLE (drop-in)
  # ============================
  # Avhengigheter (valgfri, faller tilbake hvis ikke installert)
  suppressPackageStartupMessages({
    have_cli    <- requireNamespace("cli", quietly = TRUE)
    have_crayon <- requireNamespace("crayon", quietly = TRUE)
    have_tibble <- requireNamespace("tibble", quietly = TRUE)
    have_json   <- requireNamespace("jsonlite", quietly = TRUE)
  })
  
  # Enkel farge-hjelper
  .col <- function(x, style = NULL) {
    if (!have_crayon || is.null(style)) return(x)
    f <- try(getExportedValue("crayon", style), silent = TRUE)
    if (inherits(f, "try-error")) return(x) else return(f(x))
  }
  
  # Oppdag Unicode-støtte (bruk ASCII fallback i “vanskelige” terminaler)
  .use_unicode <- isTRUE(l10n_info()[["UTF-8"]])
  
  .sym <- list(
    plan     = if (.use_unicode) "\u270E" else "[plan]",
    trade    = if (.use_unicode) "\u2705" else "[ok]",
    override = if (.use_unicode) "\u2699" else "[cfg]"
  )
  
  # Escape for cli/glue slik at { } i JSON ikke klager
  .cli_escape <- function(s) {
    s <- gsub("\\{", "{{", s, perl = TRUE)
    s <- gsub("\\}", "}}", s, perl = TRUE)
    s
  }
  
  # --------- Pene overskrifter / bannere ----------
  banner <- function(txt, col = "cyan") {
    if (have_cli) {
      getExportedValue("cli", "cat_rule")(center = paste0(" ", txt, " "), col = col)
    } else {
      cat("\n", paste0(strrep("=", 9), " ", txt, " ",
                       strrep("=", max(0, 72 - nchar(txt)))), "\n", sep = "")
    }
  }
  
  # --------- Nøkkel-verdi linjer (justert, farget) ----------
  kv <- function(k, v, width = 24) {
    kfmt <- sprintf("%-*s", width, k)
    if (have_cli) {
      getExportedValue("cli", "cli_text")(sprintf("  %s : %s", .col(kfmt, "bold"), v))
    } else {
      cat(sprintf("  %-*s : %s\n", width, k, v))
    }
  }
  
  # --------- Pen JSON-print ----------
  .pretty_json <- function(obj, indent = 2) {
    if (!have_json) return(capture.output(str(obj)))
    j <- try(jsonlite::toJSON(obj, auto_unbox = TRUE, pretty = TRUE, digits = NA), silent = TRUE)
    if (inherits(j, "try-error")) return(capture.output(str(obj)))
    return(strsplit(j, "\n")[[1]])
  }
  
  # --------- Pen tabell-print (data.frame / tibble) ----------
  pp_df <- function(x, title = NULL, n = Inf) {
    if (!is.null(title)) banner(title, col = "magenta")
    if (have_tibble) {
      print(tibble::as_tibble(x), n = n)
    } else {
      rn <- rownames(x); rownames(x) <- NULL
      print(x, row.names = FALSE)
      rownames(x) <- rn
    }
  }
  
  # --------- Pen liste/kort ----------
  pp_card <- function(lst, title = NULL) {
    if (!is.null(title)) banner(title, col = "green")
    for (nm in names(lst)) {
      val <- lst[[nm]]
      if (is.numeric(val) && length(val) == 1) val <- format(signif(val, 6), trim = TRUE)
      kv(nm, paste0(val, collapse = " "))
    }
  }
  
  # ====== Event-store (for å hente tider/plan etter trade) ======
  .__ev <- new.env(parent = emptyenv())
  
  # --------- Pyntet logger (robust mot { } i JSON) + event capture ----------
  logger_pretty <- function(event, payload) {
    ts <- format(Sys.time(), "%H:%M:%S")
    meta <- switch(event,
                   "trade_plan"    = list(icon = .sym$plan,     col = "cyan",   title = "PLAN"),
                   "trade"         = list(icon = .sym$trade,    col = "green",  title = "TRADE"),
                   "demo_override" = list(icon = .sym$override, col = "yellow", title = "OVERRIDE"),
                   list(icon = if (.use_unicode) "\u2022" else "*", col = "white", title = toupper(event))
    )
    # Capture siste plan/trade med timing
    if (identical(event, "trade_plan")) {
      .__ev$last_plan <- payload
    }
    
    if (identical(event, "trade")) {
      # alltid behold last_trade (rå payload)
      .__ev$last_trade <- payload
      
      # Hvis dette er attempt_ok (inneholder tider), MERGE payload med eksisterende ev-innhold
      # i stedet for å overskrive — behold per-leg timing som .place_leg_timed() legger til.
      if (is.list(payload) && !is.null(payload$result) && identical(payload$result, "attempt_ok")) {
        prev <- .__ev$last_attempt_ok %||% list()
        
        # Start med payload, men bevar prev$legs om de finnes
        merged <- payload
        
        prev_legs <- prev$legs %||% list()
        payload_legs <- merged$legs %||% list()
        
        if (length(prev_legs) > 0) {
          # prioriter prev_legs (de er skrevet per leg i .place_leg_timed),
          # men legg også på eventuelle legs som kom i payload
          merged$legs <- c(prev_legs, payload_legs)
        } else {
          merged$legs <- payload_legs
        }
        
        # Rekalkuler summer robust fra merged$legs
        legs_list <- merged$legs %||% list()
        broker_sum <- if (length(legs_list) > 0) sum(vapply(legs_list, function(l) as.numeric(l$time_broker_s %||% 0), numeric(1))) else 0
        wall_sum   <- if (length(legs_list) > 0) sum(vapply(legs_list, function(l) as.numeric(l$time_wall_s %||% 0), numeric(1))) else 0
        
        merged$legs_summary <- list(
          n_legs = length(legs_list),
          broker_sum_s = broker_sum,
          wall_sum_s = wall_sum
        )
        
        # Sett/tilbakestill totalfelter dersom de ikke finnes i payload
        merged$time_legs_total_s <- merged$time_legs_total_s %||% wall_sum
        merged$time_legs_total_broker_s <- merged$time_legs_total_broker_s %||% broker_sum
        
        # Lagre merged struktur tilbake i event-store
        .__ev$last_attempt_ok <- merged
      }
    }
    
    hdr <- sprintf("[%s] %s %s", ts, meta$icon, meta$title)
    if (have_cli) {
      getExportedValue("cli", "cli_text")(.col(.cli_escape(hdr), "bold"))
      j <- .pretty_json(payload)
      for (ln in j) getExportedValue("cli", "cli_text")(.cli_escape(paste0("   ", .col(ln, meta$col))))
    } else {
      cat(.col(hdr, "bold"), "\n", paste0("   ", .pretty_json(payload)), "\n", sep = "")
    }
  }
  
  # Slå på pen konsoll
  options(
    arb.core_logger = logger_pretty,
    pillar.sigfig   = 6,
    pillar.subtle   = TRUE
  )
  
  # ---------- Ta vare på gamle options + sett demo-profil ----------
  .__old_opts <- options(
    arb.dry_run                        = FALSE,   # demo kjører uten faktiske ordre
    arb.topK.print                     = 15L,
    arb.print.core_verbose             = TRUE,
    arb.print.core_summary             = TRUE,
    arb.print.core_only_edge_or_profit = FALSE,
    arb.print.profit_only              = FALSE,
    arb.stream.include_heartbeats      = FALSE
  )
  on.exit({ options(.__old_opts) }, add = TRUE)
  
  # ---------- Fallback for tri_arbitrage_pnl hvis den ikke finnes ----------
  if (!exists("tri_arbitrage_pnl")) {
    tri_arbitrage_pnl <- function(S, X, Y, state, start_qty_base = 100,
                                  fee_pct = getOption("arb.fee_pct", 0)) {
      if (exists("tri_pnl_cpp")) {
        cc <- state$ccys
        start_i <- match(S, cc); mid_i <- match(X, cc); end_i <- match(Y, cc)
        route_idx <- cbind(mid_i, end_i)
        as.list(tri_pnl_cpp(start_i, route_idx, state$BID, state$ASK,
                            start_qty_base, fee_pct)[1,])
      } else {
        get_leg <- function(from_i, to_i, BID, ASK) {
          rb <- BID[from_i, to_i]; ra <- ASK[to_i, from_i]
          if (is.finite(rb)) list(side=1L, rate=rb) else
            if (is.finite(ra)) list(side=0L, rate=1/ra) else
              list(side=NA, rate=NA)
        }
        cc <- state$ccys
        iS <- match(S, cc); iX <- match(X, cc); iY <- match(Y, cc)
        L1 <- get_leg(iS, iX, state$BID, state$ASK)
        L2 <- get_leg(iX, iY, state$BID, state$ASK)
        L3 <- get_leg(iY, iS, state$BID, state$ASK)
        if (!all(is.finite(c(L1$rate, L2$rate, L3$rate)))) return(list(ok=FALSE))
        eff <- (1 - fee_pct)
        f <- start_qty_base * L1$rate*eff * L2$rate*eff * L3$rate*eff
        list(ok=TRUE, final_base=f, netPnL=f-start_qty_base,
             pnl_after_costs=f-start_qty_base,
             pnl_pct = (f/start_qty_base - 1)*100,
             leg1_side=L1$side, leg2_side=L2$side, leg3_side=L3$side)
      }
    }
  }
  
  # ---------- Små hjelpere for demo ----------
  instrument_available0 <- function(instr, state){
    syms <- try(state$DS$list_symbols(), silent = TRUE)
    if (inherits(syms, "try-error") || is.null(syms)) return(NA) # ukjent -> NA (ikke blokker demo)
    instr %in% syms
  }
  
  # ---------- (A) Live 3-legs (tvang, mikro) ----------
  demo_force_three_leg_live <- function(state,
                                        route = c("USD","JPY","EUR","USD"),
                                        notional_S = 10) {
    stopifnot(length(route) == 4, route[1] == route[4])
    banner("DEMO: LIVE 3-LEGS (tvang, mikro)")
    cat("Route:", paste(route, collapse=" -> "), "| Notional:", notional_S, route[1], "\n")
    
    instrument_available <- function(instr, state){
      syms <- try(state$DS$list_symbols(), silent = TRUE)
      if (inherits(syms, "try-error") || is.null(syms)) return(NA)
      instr %in% syms
    }
    legs <- list(
      pick_leg(route[1], route[2], state),
      pick_leg(route[2], route[3], state),
      pick_leg(route[3], route[1], state)
    )
    for (i in 1:3) {
      L <- legs[[i]]
      cat(sprintf(" Leg %d: %s %s (listed=%s)\n",
                  i,
                  if (is.null(L)) "N/A" else L$instrument,
                  if (is.null(L)) ""    else paste0("| side=", L$side),
                  if (is.null(L)) "?"   else as.character(instrument_available(L$instrument, state))))
    }
    
    op_bak <- options(arb.dry_run = FALSE)
    on.exit(options(op_bak), add = TRUE)
    
    ok <- execute_triangle(route_vec = route, notional_S = notional_S, state = state)
    kv("Resultat", ok)
    invisible(ok)
  }
  
  # ====== TRACE & STATS for FORCED CANDIDATE ======
  
  # ROBUST leg-trace: tåler manglende/NA-priser og viser flyt
  .build_leg_trace <- function(S, X, Y, state, start_qty) {
    # Hent legs & priser via pick_leg
    L1 <- pick_leg(S, X, state)
    L2 <- pick_leg(X, Y, state)
    L3 <- pick_leg(Y, S, state)
    
    a0 <- as.numeric(start_qty)
    
    p1 <- if (!is.null(L1$price) && is.finite(L1$price)) L1$price else NA_real_
    p2 <- if (!is.null(L2$price) && is.finite(L2$price)) L2$price else NA_real_
    p3 <- if (!is.null(L3$price) && is.finite(L3$price)) L3$price else NA_real_
    
    a1 <- if (identical(L1$side, "sell")) a0 * p1 else a0 / p1
    a2 <- if (identical(L2$side, "sell")) a1 * p2 else a1 / p2
    a3 <- if (identical(L3$side, "sell")) a2 * p3 else a2 / p3
    
    data.frame(
      leg        = c(1L, 2L, 3L),
      from_ccy   = c(S, X, Y),
      to_ccy     = c(X, Y, S),
      side       = c(L1$side, L2$side, L3$side),
      instrument = c(L1$instrument, L2$instrument, L3$instrument),
      price      = c(p1, p2, p3),
      amt_in     = c(a0, a1, a2),
      amt_out    = c(a1, a2, a3),
      stringsAsFactors = FALSE
    )
  }
  
  .print_forced_stats_and_trace <- function(S, X, Y, state, start_qty) {
    # Hent timing fra siste attempt_ok hvis finnes (trygt)
    ev <- get0(".__ev", ifnotfound = NULL)
    att <- if (!is.null(ev)) ev$last_attempt_ok %||% list() else list()
    
    # Eval/exec tid (µs) — sikre fallbacks
    t_eval_us <- if (!is.null(att$time_eval_s)) as.numeric(att$time_eval_s) * 1e6 else NA_real_
    t_exec_us <- if (!is.null(att$time_exec_s)) as.numeric(att$time_exec_s) * 1e6 else NA_real_
    
    # Dersom legs_summary allerede finnes, les fra den. Hvis ikke, regn fra hvert leg-element.
    legs_total_us <- NA_real_
    legs_broker_total_us <- NA_real_
    
    if (!is.null(att$legs_summary)) {
      # legs_summary antas å være i sekunder; konverter til µs for visning
      if (!is.null(att$time_legs_total_s)) legs_total_us <- as.numeric(att$time_legs_total_s) * 1e6
      if (!is.null(att$time_legs_total_broker_s)) legs_broker_total_us <- as.numeric(att$time_legs_total_broker_s) * 1e6
      # backfill fra legs_summary feltene dersom de finnes direkte
      if (is.null(legs_total_us) || !is.finite(legs_total_us)) {
        if (!is.null(att$legs_summary$wall_sum_s)) legs_total_us <- as.numeric(att$legs_summary$wall_sum_s) * 1e6
      }
      if (is.null(legs_broker_total_us) || !is.finite(legs_broker_total_us)) {
        if (!is.null(att$legs_summary$broker_sum_s)) legs_broker_total_us <- as.numeric(att$legs_summary$broker_sum_s) * 1e6
      }
    }
    
    # Hvis vi fortsatt mangler summer, prøv å regne dem fra hvert leg-element (robust fallback)
    if ((!is.finite(legs_total_us) || is.na(legs_total_us)) ||
        (!is.finite(legs_broker_total_us) || is.na(legs_broker_total_us))) {
      legs <- att$legs %||% list()
      if (length(legs) > 0) {
        broker_sum_s <- sum(vapply(legs, function(l) as.numeric(l$time_broker_s %||% 0), numeric(1)))
        wall_sum_s   <- sum(vapply(legs, function(l) as.numeric(l$time_wall_s %||% 0), numeric(1)))
        # konverter til µs
        if (!is.finite(legs_broker_total_us) || is.na(legs_broker_total_us)) legs_broker_total_us <- broker_sum_s * 1e6
        if (!is.finite(legs_total_us) || is.na(legs_total_us)) legs_total_us <- wall_sum_s * 1e6
      }
    }
    
    # Demo-PnL (tri_arbitrage_pnl er stub mens vi er i forced-modus)
    pnl <- tri_arbitrage_pnl(S, X, Y, state = state, start_qty_base = start_qty)
    demo_final <- pnl$final_base %||% start_qty
    demo_pnl   <- (demo_final - start_qty)
    demo_bps   <- 1e4 * (demo_final / start_qty - 1)
    
    # Print stats-kort — bruk de lokale variablene (ingen udefinerte navn)
    pp_card(list(
      route_compute      = if (is.finite(t_eval_us)) gsub(" ", "\u00A0", fmt_us(t_eval_us)) else "NA",
      execute_trade      = if (is.finite(t_exec_us)) gsub(" ", "\u00A0", fmt_us(t_exec_us)) else "NA",
      legs_total         = if (is.finite(legs_total_us)) gsub(" ", "\u00A0", fmt_us(legs_total_us)) else "NA",
      legs_broker_total  = if (is.finite(legs_broker_total_us)) gsub(" ", "\u00A0", fmt_us(legs_broker_total_us)) else "NA",
      size_start         = start_qty,
      demo_pnl           = signif(demo_pnl, 6),
      demo_pnl_bps       = round(demo_bps, 3)
    ), title = "FORCED STATS – compute/execute (\u00B5s) + demo-PnL")
    
    # Leg-trace (valutaflyt)
    trace <- .build_leg_trace(S, X, Y, state, start_qty)
    trace_fmt <- transform(
      trace,
      price   = fmt_num(price, 6),
      amt_in  = fmt_num(amt_in, 6),
      amt_out = fmt_num(amt_out, 6)
    )
    pp_df(trace_fmt[,c("leg","instrument","side","from_ccy","to_ccy","price","amt_in","amt_out")],
          title = "FORCED TRACE – valutaflyt pr. legg")
    
    # Kompakt rute-oversikt
    kv("Start", sprintf("%s %s", fmt_num(start_qty, 6), S))
    kv("Etter leg 1", sprintf("%s %s (%s @ %s)",
                              trace_fmt$amt_out[1], trace$to_ccy[1],
                              trace$side[1], trace$price[1]))
    kv("Etter leg 2", sprintf("%s %s (%s @ %s)",
                              trace_fmt$amt_out[2], trace$to_ccy[2],
                              trace$side[2], trace$price[2]))
    kv("Etter leg 3", sprintf("%s %s (%s @ %s)",
                              trace_fmt$amt_out[3], S,
                              trace$side[3], trace$price[3]))
    kv("Slutt (demo)", sprintf("%s %s  |  \u0394= %s (%s bps)",
                               fmt_num(demo_final, 6), S,
                               signif(demo_pnl, 6), round(demo_bps, 3)))
  }
  
  # ---------- (B) DEMO: tving motor-kandidat + “positiv” PnL i 1 runde ----------
  with_demo_forced_candidate <- function(state,
                                         start_currency = "USD",
                                         mid = "JPY",
                                         end = "EUR",
                                         bankroll_demo = 10,        # mikrostørrelse
                                         live = TRUE) {
    stopifnot(is.matrix(state$M), start_currency %in% rownames(state$M))
    cc    <- rownames(state$M)
    s_i   <- match(start_currency, cc)
    mid_i <- match(mid, cc)
    end_i <- match(end, cc)
    if (any(is.na(c(s_i, mid_i, end_i)))) stop("Ugyldig ccys i demo-kandidat.")
    
    # 1) Ta vare på original-funksjoner og options
    eval_topK_orig <- engine_eval_topK
    pnl_orig <- if (exists("tri_arbitrage_pnl")) get("tri_arbitrage_pnl", .GlobalEnv) else NULL
    op_bak <- options(
      arb.dry_run                = !isTRUE(live),
      arb.min_edge_bps           = -1e9,          # ikke gate på min edge
      arb.max_notional_start     = bankroll_demo, # hard cap på start
      arb.frac_kelly             = 1,             # ikke nedskalér under cap
      arb.cooldown_sec           = 0.000,         # fjern cooldown for demo
      arb.spread_default_cap_bps = 500            # høyt cap, unngå spread-gating i demo
    )
    # Nullstill last trade-timestamp slik at cooldown ikke slår inn i gammel state
    if (exists(".trd_last_ts", envir = .GlobalEnv, inherits = FALSE)) {
      assign(".trd_last_ts", 0, envir = .GlobalEnv)
    }
    
    logger <- getOption("arb.core_logger", function(...) invisible(NULL))
    logger("demo_override", list(active = TRUE,
                                 mode = "forced_candidate",
                                 live_orders = isTRUE(live),
                                 route = c(start_currency, mid, end, start_currency),
                                 bankroll_demo = bankroll_demo))
    
    on.exit({
      # restore alt
      assign("engine_eval_topK", eval_topK_orig, envir = .GlobalEnv)
      if (!is.null(pnl_orig)) assign("tri_arbitrage_pnl", pnl_orig, envir = .GlobalEnv) else {
        if (exists("tri_arbitrage_pnl", envir = .GlobalEnv)) rm(tri_arbitrage_pnl, envir = .GlobalEnv)
      }
      options(op_bak)
      logger("demo_override", list(active = FALSE))
    }, add = TRUE)
    
    # 2) Overstyr engine_eval_topK til å levere AKKURAT vår kandidat – og med edge > trigger
    thr_frac <- edge_trigger_threshold(
      fee_pct     = getOption("arb.fee_pct", 0),
      slip_frac   = (getOption("arb.assumed_slip_bps", 0)/1e4),
      buffer_frac = (getOption("arb.safety_buffer_bps", 0)/1e4)
    )
    fake_edge <- as.numeric(thr_frac + 0.0002)  # litt over trigger
    assign("engine_eval_topK",
           function(K, fee_pct, slip_base_frac, buf_base_frac, k_slip, rvbps_fallback_bps, start_qty_base) {
             list(idx = 1L,
                  mid_i = as.integer(mid_i),
                  end_i = as.integer(end_i),
                  edge  = as.numeric(fake_edge))
           },
           envir = .GlobalEnv)
    
    # 3) Overstyr tri_arbitrage_pnl til å returnere POSITIV etter-kost PnL (demo ca. 5 bps)
    tri_stub <- function(S, X, Y, state, start_qty_base = 100, ...) {
      fb <- start_qty_base * 1.0005
      list(ok=TRUE, final_base=fb, netPnL=fb-start_qty_base,
           pnl_after_costs=fb-start_qty_base, pnl_pct=(fb/start_qty_base-1)*100,
           leg1_side=1L, leg2_side=1L, leg3_side=1L)
    }
    assign("tri_arbitrage_pnl", tri_stub, envir = .GlobalEnv)
    
    # 4) Kjør én runde via maybe_trade_best_triangle (sender ordre hvis live=TRUE)
    banner(sprintf("DEMO: FORCED CANDIDATE + POS PnL (%s->%s->%s->%s)",
                   start_currency, mid, end, start_currency), col = "cyan")
    t0 <- proc.time()[["elapsed"]]
    ok <- maybe_trade_best_triangle(state = state, start_currency = start_currency, bankroll = bankroll_demo)
    t1 <- proc.time()[["elapsed"]]
    
    kv("Resultat (maybe_trade_best_triangle)", ok)
    
    # --- NYE UTSKRIFTER (i ønsket rekkefølge) ---
    ## 1) Print PLAN (fra logger-capture .__ev$last_plan) som pretty JSON
    plan_env <- get0(".__ev", envir = .GlobalEnv, ifnotfound = NULL)
    plan <- if (!is.null(plan_env)) plan_env$last_plan else NULL
    if (!is.null(plan)) {
      cat(sprintf("[%s] %s\n", format(Sys.time(), "%H:%M:%S"), .sym$plan))
      cat(jsonlite::toJSON(plan, auto_unbox = TRUE, pretty = TRUE, digits = NA), "\n")
    }
    
    ## 2) The per-leg logs have already been printed live by .place_leg_timed,
    ##    they appear in stdout in the order legs were sent.
    
    ## 3) Print TRADE (last_trade) as JSON if present
    last_trade_env <- get0(".__ev", envir = .GlobalEnv, ifnotfound = NULL)
    last_trade <- if (!is.null(last_trade_env)) last_trade_env$last_trade else NULL
    if (!is.null(last_trade)) {
      cat(sprintf("[%s] %s\n", format(Sys.time(), "%H:%M:%S"), .sym$trade))
      cat(jsonlite::toJSON(last_trade, auto_unbox = TRUE, pretty = TRUE, digits = NA), "\n")
    }
    
    ## 4) Print ATTEMPT / attempt_ok details (dyn_edge etc.) if present
    att_env <- get0(".__ev", envir = .GlobalEnv, ifnotfound = NULL)
    att <- if (!is.null(att_env)) att_env$last_attempt_ok else NULL
    if (!is.null(att)) {
      cat(sprintf("[%s] %s\n", format(Sys.time(), "%H:%M:%S"), .sym$trade))
      cat(jsonlite::toJSON(att, auto_unbox = TRUE, pretty = TRUE, digits = NA), "\n")
    } else {
      # fallback: print total wall time
      total_us <- (t1 - t0) * 1e6
      kv("Total wall-time (fallback)", fmt_us(total_us))
    }
    
    # 5) Etter kjøring: vis compute/execute i µs + leg-trace + demo-PnL (samme som før)
    .print_forced_stats_and_trace(start_currency, mid, end, state, bankroll_demo)
    
    invisible(ok)
  }
  
  # =========================================================
  # 0) AUTH + SNAPSHOT + HEALTH CHECKS
  # =========================================================
  banner("0) AUTH + SNAPSHOT + HEALTH")
  kv("Auth", DS$has_auth())
  snap <- DS$snapshot(c("EUR_USD","USD_JPY","EUR_JPY"))
  pp_df(snap[,1:4], title = "Snapshot (første 4 kolonner)")
  
  # C++ wrappers status
  cpp_ok <- isTRUE(try(engine_wrappers_ready(), silent = TRUE))
  kv("C++ wrappers ready", cpp_ok)
  
  # =========================================================
  # 1) INIT STATE + MATRISER
  # =========================================================
  banner("1) INIT STATE + MATRISER")
  
  state <- init_state_and_engine(
    ROOT        = ROOT,
    DS          = DS,
    instruments = c("EUR_USD","USD_JPY","EUR_JPY"),
    start_ccy   = getOption("arb.start_ccy","USD")
  )
  kv("Valutaer (ccys)", paste(state$ccys, collapse = ", "))
  
  ensure_M(state)
  pp_df(state$M, title = "Matrix M")
  kv("M dim", paste(dim(state$M), collapse="x"))
  kv("BID/ASK dim", paste(dim(state$BID), collapse="x"))
  
  # =========================================================
  # 2) SPREAD & LIKVIDITET (bps + sjekk)
  # =========================================================
  banner("2) SPREAD & LIKVIDITET (bps + sjekk)")
  pair_spread_bps2 <- function(a, b, state = .state) {
    pair_spread_bps2_cpp(a, b, state$BID, state$ASK, state$ccys)
  }
  sp1 <- pair_spread_bps2("EUR","USD", state)
  sp2 <- pair_spread_bps2("USD","JPY", state)
  sp3 <- pair_spread_bps2("EUR","JPY", state)
  kv("spread(EUR,USD) bps", sprintf("%.3f", sp1))
  kv("spread(USD,JPY) bps", sprintf("%.3f", sp2))
  kv("spread(EUR,JPY) bps", sprintf("%.3f", sp3))
  kv("liq(EUR->USD)", has_liquidity("EUR","USD",  state=state))
  kv("liq(USD->JPY)", has_liquidity("USD","JPY",  state=state))
  kv("liq(EUR->JPY)", has_liquidity("EUR","JPY",  state=state))
  
  # =========================================================
  # 3) VOL BUFFER (mid-basert) + DYNAMISK SLIPP
  # =========================================================
  banner("3) VOL BUFFER (mid-basert) + DYNAMISK SLIPP")
  
  for (p in c("EUR/USD","USD/JPY","EUR/JPY")) {
    x <- state$latest[[p]]; mid <- if (is.null(x)) NA_real_ else 0.5*(x$bid + x$ask)
    if (is.finite(mid)) for (k in 1:8) push_mid(p, mid)
  }
  rvbps <- route_vol_bps(c("USD/JPY","JPY/EUR","EUR/USD"))
  kv("route_vol_bps(USD-JPY-EUR-USD)", sprintf("%.2f bps", rvbps %||% NA_real_))
  
  # =========================================================
  # 4) ENGINE-KANDIDATER (Top-K fra C++) + Viability
  # =========================================================
  banner("4) ENGINE-KANDIDATER (Top-K) + VIABILITY")
  
  res <- try(engine_eval_topK(
    K = getOption("arb.topK.print", 15L),
    fee_pct = getOption("arb.fee_pct", 0),
    slip_base_frac = (getOption("arb.assumed_slip_bps", 0))/1e4,
    buf_base_frac  = (getOption("arb.safety_buffer_bps", 0))/1e4,
    k_slip = getOption("arb.k_slip", 0.30),
    rvbps_fallback_bps = getOption("arb.rvbps_fallback_bps", 10.0),
    start_qty_base = 200
  ), silent = TRUE)
  
  if (inherits(res, "try-error") || is.null(res) || !length(res$idx)) {
    kv("Top-K", "ingen kandidater fra motor")
  } else {
    fee      <- getOption("arb.fee_pct", 0)
    slip_b   <- getOption("arb.assumed_slip_bps", 0)/1e4
    k_sl     <- getOption("arb.k_slip", 0.30)
    buf      <- getOption("arb.safety_buffer_bps", 0)/1e4
    slip_dyn <- slip_b + if (is.finite(rvbps)) k_sl*(rvbps/1e4) else 0
    thr_bps  <- 1e4 * edge_trigger_threshold(fee_pct = fee, slip_frac = slip_dyn, buffer_frac = buf)
    
    show <- data.frame(
      mid = state$ccys[ res$mid_i ],
      end = state$ccys[ res$end_i ],
      edge_bps_mid_only = round(1e4*res$edge, 3),
      edge_minus_trigger_bps = round(1e4*res$edge - thr_bps, 3),
      viable = (1e4*res$edge >= thr_bps),
      stringsAsFactors = FALSE
    )
    pp_df(show, title = "Top-K kandidater (formatert)")
  }
  
  # =========================================================
  # 5) TRIGGER-MATTE (edge vs fee+slip+buffer) for en rute
  # =========================================================
  banner("5) TRIGGER-MATTE (edge vs fee+slip+buffer)")
  
  S <- "USD"; X <- "JPY"; Y <- "EUR"
  fee <- getOption("arb.fee_pct", 0)
  slip_base <- getOption("arb.assumed_slip_bps", 0)/1e4
  k_slip    <- getOption("arb.k_slip", 0.30)
  buf       <- getOption("arb.safety_buffer_bps", 0)/1e4
  slip_dyn  <- slip_base + if (is.finite(rvbps)) k_slip*(rvbps/1e4) else 0
  thr_frac  <- edge_trigger_threshold(fee_pct = fee, slip_frac = slip_dyn, buffer_frac = buf)
  thr_bps   <- 1e4 * thr_frac
  
  M <- state$M; idx <- function(c) match(c, rownames(M))
  mid_edge_bps <- 1e4 * ((M[idx(S), idx(X)] * M[idx(X), idx(Y)]) / M[idx(S), idx(Y)] - 1)
  
  kv("edge(mid-only) bps", sprintf("%.3f", mid_edge_bps))
  kv("trigger parts", sprintf("fee=%.3f + slip=%.3f + buffer=%.3f bps",
                              fee*1e4, slip_dyn*1e4, buf*1e4))
  kv("trigger (bps)", sprintf("%.3f = fee+slip+buffer", thr_bps))
  kv("edge-minus-trigger", sprintf("%.3f bps", mid_edge_bps - thr_bps))
  
  # =========================================================
  # 6) PnL-SANITY (BID/ASK etter kost)
  # =========================================================
  banner("6) PnL-SANITY (BID/ASK etter kost) for USD->JPY->EUR->USD")
  
  start_qty <- 200
  pnl <- tri_arbitrage_pnl(S, X, Y, state = state, start_qty_base = start_qty)
  pp_card(list(
    ok = pnl$ok,
    final_base = round(pnl$final_base %||% NA_real_, 5),
    netPnL = round(pnl$netPnL %||% NA_real_, 5),
    pnl_after_costs = round(pnl$pnl_after_costs %||% pnl$netPnL %||% NA_real_, 5),
    pnl_bps = round(1e4 * ((pnl$final_base %||% start_qty)/start_qty - 1), 3),
    legs = paste(c(pnl$leg1_side, pnl$leg2_side, pnl$leg3_side), collapse = " ")
  ), title = "PnL – BID/ASK etter kost")
  
  # =========================================================
  # 7) SIZING (Kelly-justert) + cap/min info
  # =========================================================
  banner("7) SIZING (Kelly-justert)")
  
  edge_net_bps <- mid_edge_bps - thr_bps
  rvbps_eff    <- if (is.finite(rvbps)) rvbps else getOption("arb.rvbps_fallback_bps", 10.0)
  bankroll     <- getOption("arb.bankroll_default", 10000)
  size_S_raw   <- kelly_size(edge_net_bps = edge_net_bps,
                             vol_bps_route = rvbps_eff,
                             bankroll = bankroll)
  cap          <- getOption("arb.max_notional_start", 25000)
  min_units    <- getOption("arb.min_units", 1L)
  size_S       <- max(min_units, min(size_S_raw, cap))
  
  kv("bankroll", bankroll)
  kv("edge_net_bps", sprintf("%.3f", edge_net_bps))
  kv("rvbps_eff", sprintf("%.2f", rvbps_eff))
  kv("Kelly size (raw)", round(size_S_raw))
  kv("Kelly size (clamped)", sprintf("%d (cap=%d, min_units=%d)", round(size_S), cap, min_units))
  
  # =========================================================
  # 8) ROUTE EXPLAINER (instrumenter & sides)
  # =========================================================
  banner("8) ROUTE EXPLAINER (instrumenter & sides)")
  
  leg1 <- try(pick_leg(S, X, state), silent = TRUE)
  leg2 <- try(pick_leg(X, Y, state), silent = TRUE)
  leg3 <- try(pick_leg(Y, S, state), silent = TRUE)
  
  fmt_leg <- function(L){
    if (inherits(L, "try-error") || is.null(L)) return("N/A")
    av <- instrument_available0(L$instrument, state)
    sprintf("%s | side=%s | px≈%s | listed=%s",
            L$instrument, L$side, format(round(L$price %||% NA_real_, 6), nsmall=6),
            if (is.na(av)) "unknown" else as.character(av))
  }
  kv("Leg 1 (S->X)", fmt_leg(leg1))
  kv("Leg 2 (X->Y)", fmt_leg(leg2))
  kv("Leg 3 (Y->S)", fmt_leg(leg3))
  
  # =========================================================
  # 9) SKANN: alle USD-trekanter (BID/ASK PnL-bps)
  # =========================================================
  banner("9) SKANN: alle USD-trekanter (BID/ASK PnL-bps)")
  
  scan_tri <- function(S="USD", start_qty=200, state=state){
    cc <- state$ccys; rows <- list()
    for (X in setdiff(cc,S)) for (Y in setdiff(cc,c(S,X))){
      r <- tri_arbitrage_pnl(S,X,Y, state=state, start_qty_base=start_qty)
      rows[[paste(S,X,Y,sep="-")]] <- data.frame(
        start=S, mid=X, end=Y, pnl=r$pnl_after_costs %||% NA_real_,
        pnl_bps = (r$pnl_after_costs %||% NA_real_)/start_qty*1e4,
        ok = isTRUE(r$ok), stringsAsFactors = FALSE
      )
    }
    d <- do.call(rbind, rows)
    d[order(-d$pnl_bps),]
  }
  pp_df(scan_tri("USD", 200, state), title = "Skann: USD-trekanter (pnl_bps)")
  
  # =========================================================
  # 10) WHAT-IF: følsomhet (fee/slip/buffer)
  # =========================================================
  banner("10) WHAT-IF: følsomhet for (fee/slip/buffer)")
  
  rvbps0 <- rvbps
  whatif <- function(fee = 0, slip_bps = 0, k = 0.30, buf_bps = 0, rvbps_in = rvbps0) {
    thr <- edge_trigger_threshold(
      fee_pct    = fee,
      slip_frac  = (slip_bps/1e4) + if (is.finite(rvbps_in)) k*(rvbps_in/1e4) else 0,
      buffer_frac= (buf_bps/1e4)
    )
    data.frame(
      fee = fee,
      slip_bps = slip_bps,
      k_slip = k,
      buffer_bps = buf_bps,
      trigger_bps = round(1e4*thr, 3),
      edge_minus_trigger_bps = round(mid_edge_bps - 1e4*thr, 3),
      stringsAsFactors = FALSE
    )
  }
  wf <- rbind(
    whatif(fee = 0, slip_bps = 0, k = 0,    buf_bps = 0),
    whatif(fee = getOption("arb.fee_pct", 0),
           slip_bps = getOption("arb.assumed_slip_bps", 0),
           k = getOption("arb.k_slip", 0.30),
           buf_bps = getOption("arb.safety_buffer_bps", 0)),
    whatif(fee = 0.0001, slip_bps = 2, k = 0.30, buf_bps = 2),
    whatif(fee = 0.0002, slip_bps = 5, k = 0.30, buf_bps = 3)
  )
  pp_df(wf, title = "WHAT-IF – følsomhet (fee / slip / buffer)")
  
  # =========================================================
  # 11) TØRR TRADE (logger plan/legs via arb.core_logger)
  # =========================================================
  banner("11) TØRR TRADE (logger plan/legs, ingen ordre)")
  invisible(maybe_trade_best_triangle(state = state, start_currency = S, bankroll = 200))
  
  # =========================================================
  # 12) (VALGFRITT) LIVE PROBE: ekte 3-legg med bitteliten notional (uten “fake”)
  # =========================================================
  # ----------------- TIMED-LIVE WRAPPER (LIM INN HER, FØR SEKSJON 12) -----------------
  # (Setter arb.dry_run = FALSE — SENDER ordre til broker. Sjekk at state$DS er DEMO!)
  if (!exists("state", envir = .GlobalEnv)) stop("state finnes ikke i globalt miljø — init_state_and_engine(...) må kjøres først.")
  if (is.null(state$DS)) stop("state$DS mangler. DS (broker wrapper) må være tilgjengelig i state.")
  
  # Backup aktuelle options + originale funksjoner (lagret i globals)
  .timed_op_bak <- options(
    arb.cooldown_sec = getOption("arb.cooldown_sec"),
    arb.min_interval_ms = getOption("arb.min_interval_ms"),
    arb.min_interval_fast_ms = getOption("arb.min_interval_fast_ms"),
    arb.topK.print = getOption("arb.topK.print"),
    arb.print.core_verbose = getOption("arb.print.core_verbose"),
    arb.print.core_heartbeat = getOption("arb.print.core_heartbeat"),
    arb.dry_run = getOption("arb.dry_run")
  )
  assign(".timed_op_bak", .timed_op_bak, envir = .GlobalEnv)
  
  .timed_place_leg_orig <- if (exists(".place_leg", envir = .GlobalEnv)) get(".place_leg", envir = .GlobalEnv) else NULL
  .timed_exec_orig      <- if (exists("execute_triangle", envir = .GlobalEnv)) get("execute_triangle", envir = .GlobalEnv) else NULL
  assign(".timed_place_leg_orig", .timed_place_leg_orig, envir = .GlobalEnv)
  assign(".timed_exec_orig", .timed_exec_orig, envir = .GlobalEnv)
  
  # Aggressive overrides for live demo run (sørg for demo-konto)
  options(
    arb.cooldown_sec = 0.0,
    arb.min_interval_ms = 0L,
    arb.min_interval_fast_ms = 0L,
    arb.topK.print = 8L,
    arb.print.core_verbose = FALSE,
    arb.print.core_heartbeat = FALSE,
    arb.dry_run = FALSE    # LIVE: send ordre (du har bedt om live)
  )
  
  # Leg-delay (sekunder) — SET TO ZERO to minimize delay between legs
  assign(".leg_delay_secs", c(0, 0, 0), envir = .GlobalEnv)
  assign(".leg_counter", 0L, envir = .GlobalEnv)
  
  # Timed wrapper for .place_leg (logger start/time/duration + NO SLEEP between legs)
  .place_leg_timed <- function(instrument, side, units, state = get("state", envir = .GlobalEnv)) {
    idx <- if (exists(".leg_counter", envir = .GlobalEnv)) {
      v <- get(".leg_counter", envir = .GlobalEnv) + 1L
      assign(".leg_counter", v, envir = .GlobalEnv); v
    } else {
      assign(".leg_counter", 1L, envir = .GlobalEnv); 1L
    }
    
    cat(sprintf("[LEG %d] SEND -> %s %d on %s  (t=%s)\n",
                idx, side, as.integer(units), instrument, format(Sys.time(), "%H:%M:%OS3")))
    
    leg_wall_start <- proc.time()[3]
    broker_start <- proc.time()[3]
    
    res <- tryCatch({
      if (!is.null(.timed_place_leg_orig)) {
        .timed_place_leg_orig(instrument, side, units, state)
      } else {
        state$DS$place_market(instrument = instrument, side = side, units = as.integer(units))
      }
    }, error = function(e) list(ok = FALSE, err = conditionMessage(e)))
    
    broker_end <- proc.time()[3]
    leg_wall_end <- proc.time()[3]
    
    broker_dur <- broker_end - broker_start
    wall_dur <- leg_wall_end - leg_wall_start
    
    cat(sprintf("[LEG %d] DONE  -> ok=%s  (broker-call=%.3f s)  err=%s\n",
                idx,
                ifelse(is.list(res) && isTRUE(res$ok),"TRUE","FALSE"),
                broker_dur,
                ifelse(is.list(res) && !is.null(res$err), res$err, "NULL")))
    
    # Append per-leg timing / metadata to .__ev$last_attempt_ok for later JSON-output
    ev <- get0(".__ev", ifnotfound = new.env(parent = emptyenv()))
    ev$last_attempt_ok <- ev$last_attempt_ok %||% list()
    ev$last_attempt_ok$legs <- ev$last_attempt_ok$legs %||% list()
    
    leg_rec <- list(
      idx = idx,
      instrument = instrument,
      side = side,
      units = as.integer(units),
      time_broker_s = broker_dur,
      time_wall_s = wall_dur,
      t_broker_start = broker_start,
      t_broker_end = broker_end
    )
    ev$last_attempt_ok$legs[[length(ev$last_attempt_ok$legs) + 1L]] <- leg_rec
    
    # --- Robust oppdatering av akkumulerte summer (trygt, hver leg) ---
    legs_now <- ev$last_attempt_ok$legs %||% list()
    broker_sum <- 0
    wall_sum <- 0
    if (length(legs_now) > 0) {
      broker_sum <- sum(vapply(legs_now, function(l) as.numeric(l$time_broker_s %||% 0), numeric(1)))
      wall_sum   <- sum(vapply(legs_now, function(l) as.numeric(l$time_wall_s %||% 0), numeric(1)))
    }
    ev$last_attempt_ok$legs_summary <- list(
      n_legs = length(legs_now),
      broker_sum_s = broker_sum,
      wall_sum_s = wall_sum
    )
    # alternative felter brukbare senere
    ev$last_attempt_ok$time_legs_total_s <- wall_sum
    ev$last_attempt_ok$time_legs_total_broker_s <- broker_sum
    
    assign(".__ev", ev, envir = .GlobalEnv)
    
    # Valgfri: skriv kumulativ linje (micro / s)
    cat(sprintf("[LEGS SUM] cumulative wall=%.3f s | broker=%.3f s  (n=%d)\n",
                ev$last_attempt_ok$time_legs_total_s %||% 0,
                ev$last_attempt_ok$time_legs_total_broker_s %||% 0,
                ev$last_attempt_ok$legs_summary$n_legs %||% 0))
    
    # Use zero sleep (tuned); keep Sys.sleep only if non-zero value provided
    delays2 <- get0(".leg_delay_secs", ifnotfound = c(0,0,0), envir = .GlobalEnv)
    sleep <- if (length(delays2) >= idx) delays2[idx] else tail(delays2, 1)
    if (is.finite(sleep) && sleep > 0) {
      cat(sprintf("[LEG %d] sleeping %.3f s before next leg\n", idx, sleep))
      Sys.sleep(sleep)
    }
    
    res
  }
  
  assign(".place_leg", .place_leg_timed, envir = .GlobalEnv)
  
  # install execute wrapper only if original exists
  if (!is.null(.timed_exec_orig)) {
    execute_triangle_timed <- function(route_vec, notional_S, state = get("state", envir = .GlobalEnv), dry_run = NULL) {
      # reset per-run leg storage
      assign(".leg_counter", 0L, envir = .GlobalEnv)
      ev <- get0(".__ev", ifnotfound = new.env(parent = emptyenv()))
      ev$last_attempt_ok <- list(legs = list())
      assign(".__ev", ev, envir = .GlobalEnv)
      
      t_exec_start <- proc.time()[3]
      res <- tryCatch({
        .timed_exec_orig(route_vec = route_vec, notional_S = notional_S, state = state, dry_run = dry_run)
      }, error = function(e) { cat("execute_triangle error:", conditionMessage(e), "\n"); FALSE })
      t_exec_end <- proc.time()[3]
      
      # gather/run-time summary
      ev <- get0(".__ev", ifnotfound = new.env(parent = emptyenv()))
      ev$last_attempt_ok <- ev$last_attempt_ok %||% list()
      # prefer explicit time set by caller, else set measured exec time
      ev$last_attempt_ok$time_exec_s <- ev$last_attempt_ok$time_exec_s %||% (t_exec_end - t_exec_start)
      
      # compute sums from legs if present (safe)
      legs <- ev$last_attempt_ok$legs %||% list()
      if (length(legs) > 0) {
        broker_sum <- sum(vapply(legs, function(l) as.numeric(l$time_broker_s %||% 0), numeric(1)))
        wall_sum   <- sum(vapply(legs, function(l) as.numeric(l$time_wall_s %||% 0), numeric(1)))
        ev$last_attempt_ok$legs_summary <- list(
          n_legs = length(legs),
          broker_sum_s = broker_sum,
          wall_sum_s = wall_sum
        )
        ev$last_attempt_ok$time_legs_total_s <- wall_sum
        ev$last_attempt_ok$time_legs_total_broker_s <- broker_sum
      } else {
        # sørg for minst en tom summary, slik at kallende printer får konsistente felt
        ev$last_attempt_ok$legs_summary <- ev$last_attempt_ok$legs_summary %||% list(
          n_legs = 0L, broker_sum_s = 0, wall_sum_s = 0
        )
        ev$last_attempt_ok$time_legs_total_s <- ev$last_attempt_ok$time_legs_total_s %||% 0
        ev$last_attempt_ok$time_legs_total_broker_s <- ev$last_attempt_ok$time_legs_total_broker_s %||% 0
      }
      
      assign(".__ev", ev, envir = .GlobalEnv)
      assign(".leg_counter", 0L, envir = .GlobalEnv)
      res
    }
    assign("execute_triangle", execute_triangle_timed, envir = .GlobalEnv)
  } else {
    warning("Original execute_triangle ikke funnet — wrapper ikke installert (fortsett likevel).")
  }
  # Restore-funksjon (bruk ved behov)
  restore_timed_demo <- function() {
    opbak <- get0(".timed_op_bak", ifnotfound = NULL, envir = .GlobalEnv)
    if (!is.null(opbak)) options(opbak)
    plorig <- get0(".timed_place_leg_orig", ifnotfound = NULL, envir = .GlobalEnv)
    if (!is.null(plorig)) assign(".place_leg", plorig, envir = .GlobalEnv) else if (exists(".place_leg", envir = .GlobalEnv)) rm(list = ".place_leg", envir = .GlobalEnv)
    exorig <- get0(".timed_exec_orig", ifnotfound = NULL, envir = .GlobalEnv)
    if (!is.null(exorig)) assign("execute_triangle", exorig, envir = .GlobalEnv)
    if (exists(".leg_counter", envir = .GlobalEnv)) rm(list = ".leg_counter", envir = .GlobalEnv)
    if (exists(".leg_delay_secs", envir = .GlobalEnv)) rm(list = ".leg_delay_secs", envir = .GlobalEnv)
    if (exists(".timed_op_bak", envir = .GlobalEnv)) rm(list = ".timed_op_bak", envir = .GlobalEnv)
    if (exists(".timed_place_leg_orig", envir = .GlobalEnv)) rm(list = ".timed_place_leg_orig", envir = .GlobalEnv)
    if (exists(".timed_exec_orig", envir = .GlobalEnv)) rm(list = ".timed_exec_orig", envir = .GlobalEnv)
    cat("RESTORED original options/functions for timed demo.\n")
    invisible(TRUE)
  }
  
  # ---------------------------------------------------------------------------------
  # Nå er wrapper installert — når skriptet fortsetter vil seksjon 12/13 bruke denne.
  # ---------------------------------------------------------------------------------
  do_live_probe <- TRUE
  if (isTRUE(do_live_probe)) {
    opts_bak <- options(arb.dry_run = FALSE)
    on.exit({ options(opts_bak) }, add = TRUE)
    banner("12) LIVE PROBE: forsøker tri-ordre med lav notional")
    ok_live <- try(execute_triangle(c(S, X, Y, S), notional_S = 10, state = state), silent = TRUE)
    kv("live_probe_ok", if (inherits(ok_live,"try-error")) "ERROR" else as.character(ok_live))
  }
  
  # =========================================================
  # 13) (VALGFRITT) FORCED CANDIDATE + “positiv” PnL i 1 runde
  #     - Setter en kunstig kandidat (edge > trigger)
  #     - Rapporterer liten positiv PnL i sanity
  #     - Sender ekte ordre hvis live=TRUE (mikro)
  #     - Viser compute/execute i µs + leg-by-leg valutaflyt
  # =========================================================
  do_force_candidate <- TRUE
  if (isTRUE(do_force_candidate)) {
    banner("13) FORCED CANDIDATE: grønn pipeline + 3-legg (mikro)")
    # Sett live=FALSE for å se hele “grønn pipeline” uten ordre – eller live=TRUE for ekte mikroordre
    ok_forced <- with_demo_forced_candidate(state,
                                            start_currency = "USD",
                                            mid = "JPY",
                                            end = "EUR",
                                            bankroll_demo = 10,
                                            live = TRUE)
    kv("forced_candidate_ok", as.character(ok_forced))
    banner("DEMO FERDIG", col = "green")
  }
}
