

###############################
###   üìò R SOURCE FILES    ###
###############################


==========================================================
üìÑ core_runtime.R
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/R/core_runtime.R
==========================================================
# --- Convert "EUR_USD" ‚Üí "EUR/USD"
.cr_sym_to_pair <- function(sym) gsub("_", "/", sym, fixed = TRUE)

# --- Convert "EUR/USD" ‚Üí "EUR_USD"
.cr_pair_to_sym <- function(pair) gsub("/", "_", pair, fixed = TRUE)

# --- Extract sorted list of currencies
infer_ccys_from_instruments <- function(instruments) {
  pairs <- vapply(instruments, .cr_sym_to_pair, character(1))
  parts <- strsplit(pairs, "/", fixed = TRUE)
  ccys  <- unique(unlist(parts, use.names = FALSE))
  sort(ccys[nzchar(ccys)])
}

# ---- liquidity gate (TTL cached) ----
has_liquidity <- function(from_ccy, to_ccy, state, ttl_ms = 300L) {
  key   <- paste0(from_ccy, "/", to_ccy)
  instr <- paste0(from_ccy, "_", to_ccy)
  
  now <- as.numeric(Sys.time()) * 1000
  oc <- state$ob_cache[[key]]
  if (!is.null(oc) && (now - oc$ts) < ttl_ms) return(isTRUE(oc$ok))
  
  ob <- .ds_orderbook_safe(state$DS, instr)
  ok <- is.list(ob) && length(ob) > 0
  
  state$ob_cache[[key]] <- list(ts = now, ok = ok)
  ok
}

# ---- tick handler (direct + inverse, fully consistent) ----
make_on_tick <- function(state) {
  function(sym, bid, ask, time) {
    
    if (identical(sym, "HEARTBEAT")) return(invisible())
    if (!is.finite(bid) || !is.finite(ask) || bid <= 0 || ask <= 0) return(invisible())
    
    # Normaliser
    pair <- .cr_sym_to_pair(sym)
    
    idx <- state$pair_idx[[pair]]
    if (is.null(idx)) return(invisible())
    
    a <- idx$i; b <- idx$j
    
    # --- direct update ---
    state$latest[[pair]] <- list(bid = bid, ask = ask, time = time)
    engine_push_tick(state$eng, a, b, bid, ask)
    
    state$BID[a, b] <- bid
    state$ASK[a, b] <- ask
    state$M[a, b]   <- sqrt(bid * ask)
    
    # --- inverse update (ONLY if not streamed) ---
    parts <- strsplit(pair, "/", fixed = TRUE)[[1]]
    inv_pair <- paste0(parts[2], "/", parts[1])
    
    if (!isTRUE(state$instr_set_slash[[inv_pair]])) {
      inv_idx <- state$pair_idx[[inv_pair]]
      if (!is.null(inv_idx)) {
        
        bid_inv <- 1 / ask
        ask_inv <- 1 / bid
        
        if (is.finite(bid_inv) && is.finite(ask_inv)) {
          ia <- inv_idx$i; ib <- inv_idx$j
          
          state$latest[[inv_pair]] <- list(
            bid = bid_inv,
            ask = ask_inv,
            time = time
          )
          
          engine_push_tick(state$eng, ia, ib, bid_inv, ask_inv)
          
          state$BID[ia, ib] <- bid_inv
          state$ASK[ia, ib] <- ask_inv
          state$M[ia, ib]   <- sqrt(bid_inv * ask_inv)
        }
      }
    }
    
    invisible()
  }
}


  
 




init_state <- function(DS, instruments, start_ccy = "USD") {
  
  # Valutaunivers
  ccys <- infer_ccys_from_instruments(instruments)
  
  n <- length(ccys)
  BID <- matrix(NA_real_, n, n, dimnames=list(ccys, ccys))
  ASK <- matrix(NA_real_, n, n, dimnames=list(ccys, ccys))
  M   <- matrix(NA_real_, n, n, dimnames=list(ccys, ccys))
  
  # Bygg forward+inverse mapping
  pair_idx <- list()
  for (sym in instruments) {
    p <- .cr_sym_to_pair(sym)  # EUR_USD ‚Üí EUR/USD
    parts <- strsplit(p, "/", fixed = TRUE)[[1]]
    a <- parts[1]; b <- parts[2]
    
    pair_idx[[p]] <- list(i = which(ccys == a), j = which(ccys == b))
    inv <- paste0(b, "/", a)
    
    pair_idx[[inv]] <- list(i = which(ccys == b), j = which(ccys == a))
  }
  
  # üî• sanne triangler (ikke syntetiske)
 # routes <- build_true_triangles(instruments)
  
  state <- new.env(parent = emptyenv())
  state$DS        <- DS
  state$ccys      <- ccys
  state$BID       <- BID
  state$ASK       <- ASK
  state$M         <- M
  state$pair_idx  <- pair_idx
  state$routes    <- routes
  state$start_ccy <- start_ccy
  state$latest    <- new.env()
  state$ob_cache  <- new.env()
  
  # Sett med instrumenter (underscore ‚Üí ekte OANDA-stream)
  state$instr_set <- as.list(setNames(rep(TRUE, length(instruments)), instruments))
  
  # Samme som slash
  instr_slash <- vapply(instruments, .cr_sym_to_pair, character(1))
  state$instr_set_slash <- as.list(setNames(rep(TRUE, length(instr_slash)), instr_slash))
  
  state
}

debug_route <- function(state, route_row) {
  ccys <- state$ccys
  
  S <- route_row$S
  X <- route_row$X
  Y <- route_row$Y
  
  cS <- ccys[S]; cX <- ccys[X]; cY <- ccys[Y]
  
  rd <- function(a, b) {
    bid <- state$BID[a,b]
    ask <- state$ASK[a,b]
    list(bid = bid, ask = ask)
  }
  
  leg1 <- rd(S,X)
  leg2 <- rd(X,Y)
  leg3 <- rd(Y,S)
  
  f1 <- if (is.finite(leg1$ask)) 1/leg1$ask else NA
  f2 <- if (is.finite(leg2$ask)) 1/leg2$ask else NA
  f3 <- if (is.finite(leg3$bid)) leg3$bid   else NA
  
  list(
    legs = list(leg1 = leg1, leg2 = leg2, leg3 = leg3),
    product = f1*f2*f3
  )
}









diagnose_missing_triangles <- function(instruments) {
  pairs <- vapply(instruments, function(x) gsub("_", "/", x), character(1))
  parts <- strsplit(pairs, "/", fixed = TRUE)
  ccys  <- sort(unique(unlist(parts)))
  
  has_pair <- function(a, b) paste0(a, "/", b) %in% pairs
  
  cat("\nüîç TRIANGLE DIAGNOSIS\n")
  found_any <- FALSE
  
  for (a in ccys) {
    for (b in ccys) {
      if (a == b) next
      if (!has_pair(a, b)) next
      
      for (c in ccys) {
        if (c %in% c(a, b)) next
        
        leg1 <- has_pair(a, b)
        leg2 <- has_pair(b, c)
        leg3 <- has_pair(c, a)
        
        # If at least 1 missing, print diagnosis
        if (!(leg1 && leg2 && leg3)) {
          found_any <- TRUE
          cat(sprintf(
            "\nTriangle candidate: %s ‚Üí %s ‚Üí %s ‚Üí %s\n", a, b, c, a
          ))
          cat(sprintf("   %s/%s : %s\n", a, b,  if (leg1) "OK" else "‚ùå MISSING"))
          cat(sprintf("   %s/%s : %s\n", b, c,  if (leg2) "OK" else "‚ùå MISSING"))
          cat(sprintf("   %s/%s : %s\n", c, a,  if (leg3) "OK" else "‚ùå MISSING"))
        }
      }
    }
  }
  
  if (!found_any)
    cat("‚úÖ Ingen manglende ben. Alle triangler er fullstendige!\n")
  
  invisible(TRUE)
}



==========================================================
üìÑ DirectStream copy.R
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/R/DirectStream copy.R
==========================================================
# R/DS.R  (OANDA Practice DS 0.3)  ---- robust "_" <-> "/" normalization
# - Safe for callers that sometimes pass "EUR/USD" and sometimes "EUR_USD"
# - Ensures endpoints that require URL path-safe instrument always get underscore form

DS <- local({
  ## ---------- sm√• helpers ----------
  # ==============================
  # üîê OANDA Auth-konfig
  # ==============================
  # Leser autentiseringsdetaljer fra:
  # 1. R options() (dersom du har satt dem via options(oanda.account_id=...))
  # 2. Ellers milj√∏variabler i ~/.Renviron eller .env
  # 3. Har fallback p√• standard API-url (OANDA Practice)
  # ==============================
  # --- OANDA base URLs & auth helpers ---
  `%||%` <- function(x, y) {
    if (is.null(x)) y else x
  }
  stream_base_url_f <- function() {
    getOption(
      "oanda.stream_base_url",
      Sys.getenv("OANDA_STREAM_BASE_URL", "https://stream-fxpractice.oanda.com/v3")
    )
  }
  
  base_url_f <- function() {
    getOption(
      "oanda.base_url",
      Sys.getenv("OANDA_BASE_URL", "https://api-fxpractice.oanda.com/v3")
    )
  }
  
  api_token_f <- function() {
    getOption(
      "OANDA.API_KEY",
      Sys.getenv("OANDA_API_KEY", "")
    )
  }
  
  account_id_f <- function() {
    trimws(
      getOption(
        "oanda.account_id",
        Sys.getenv("OANDA_ACCOUNT_ID", "")
      )
    )
  }

  # ==============================
  # üîÅ Symbol normalization helpers
  # ==============================
  # Pair form: "EUR/USD"
  # Instrument form: "EUR_USD"
  normalize_symbol <- function(sym) gsub("_", "/", sym, fixed = TRUE)
  denorm_symbol    <- function(pair) gsub("/", "_", pair, fixed = TRUE)
  
  # Always produce instrument-safe name for URL path segments
  as_instr <- function(x) {
    if (is.null(x) || !nzchar(x)) return("")
    # accept both "AAA_BBB" and "AAA/BBB"
    out <- gsub("/", "_", x, fixed = TRUE)
    # basic cleanup
    out <- toupper(trimws(out))
    out
  }
  
  .check_cfg <- function() {
    if (!nzchar(api_token_f()))
      stop("OANDA api_key mangler. Sett options(OANDA.API_KEY='...') eller OANDA_API_KEY.", call. = FALSE)
    if (!nzchar(account_id_f()))
      stop("OANDA account_id mangler. Sett options(oanda.account_id='...') eller OANDA_ACCOUNT_ID.", call. = FALSE)
    if (!grepl("^https?://", base_url_f()))
      stop("base_url ser rar ut: ", base_url_f(), call. = FALSE)
    if (!grepl("^https?://", stream_base_url_f()))
      stop("stream_base_url ser rar ut: ", stream_base_url_f(), call. = FALSE)
    invisible(TRUE)
  }
  
  has_auth <- function() {
    nzchar(api_token_f()) && nzchar(account_id_f())
  }
  
  # ==============================
  # üåê Request builder
  # ==============================
  .req_base <- function(url) {
    ua <- getOption("arb.user_agent", "tri-fx-arb/0.1 (R httr2)")
    timeout_sec <- getOption("oanda.http_timeout", 30)
    max_tries   <- getOption("oanda.http_max_tries", 4)
    bo_min      <- getOption("oanda.http_backoff_min", 0.4)
    bo_max      <- getOption("oanda.http_backoff_max", 1.2)
    
    httr2::request(url) |>
      httr2::req_headers(
        Authorization = paste("Bearer", api_token_f()),
        Accept        = "application/json",
        `User-Agent`  = ua
      ) |>
      httr2::req_timeout(timeout_sec) |>
      httr2::req_retry(
        max_tries = max_tries,
        backoff = ~ runif(1, bo_min, bo_max) * (2^(.x - 1))
      )
  }
  
  # ==============================
  # üßÆ Price parsing helper
  # ==============================
  .last_price <- function(x) {
    if (is.null(x) || length(x) == 0) return(NA_real_)
    
    if (is.list(x) && !is.data.frame(x)) {
      last <- x[[length(x)]]
      if (is.list(last) && !is.null(last$price)) {
        return(suppressWarnings(as.numeric(last$price)))
      }
      return(suppressWarnings(as.numeric(last)))
    }
    
    if (is.data.frame(x) && "price" %in% names(x)) {
      return(suppressWarnings(as.numeric(utils::tail(x$price, 1))))
    }
    
    suppressWarnings(as.numeric(utils::tail(x, 1)))
  }
  
  # ==============================
  # ‚úÖ Account / instrument endpoints
  # ==============================
  ping <- function() {
    .check_cfg()
    url  <- sprintf("%s/accounts/%s/summary", base_url_f(), account_id_f())
    resp <- .req_base(url) |>
      httr2::req_error(is_error = function(resp) FALSE) |>
      httr2::req_perform()
    cat("HTTP", httr2::resp_status(resp), httr2::resp_status_desc(resp), "\n")
    body <- httr2::resp_body_string(resp)
    if (nzchar(body)) cat(body, "\n")
    invisible(resp)
  }
  
  list_symbols <- function() {
    .check_cfg()
    url  <- sprintf("%s/accounts/%s/instruments", base_url_f(), account_id_f())
    resp <- .req_base(url) |> httr2::req_perform()
    httr2::resp_check_status(resp)
    j    <- jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)
    syms <- j$instruments
    out  <- syms$name[syms$type == "CURRENCY" & grepl("^[A-Z]{3}_[A-Z]{3}$", syms$name)]
    as.character(sort(unique(out)))
  }
  
  instruments_meta <- function() {
    .check_cfg()
    url  <- sprintf("%s/accounts/%s/instruments", base_url_f(), account_id_f())
    resp <- .req_base(url) |> httr2::req_perform()
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)$instruments
  }
  
  # ==============================
  # üïØÔ∏è Candles / history
  # ==============================
  .get_candles <- function(instr, granularity = "M1", count = 10, price = "BA") {
    .check_cfg()
    instr <- as_instr(instr)  # <--- critical fix (path-safe)
    url   <- sprintf("%s/instruments/%s/candles", base_url_f(), instr)
    resp  <- .req_base(url) |>
      httr2::req_url_query(granularity = granularity, count = count, price = price) |>
      httr2::req_perform()
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)
  }
  
  fetch_history <- function(instruments,
                            granularity = getOption("oanda.history.granularity", "M1"),
                            count       = getOption("oanda.history.count", 10)) {
    rows <- list()
    meta <- try(instruments_meta(), silent = TRUE)
    pip_by <- NULL
    if (!inherits(meta, "try-error") && is.data.frame(meta)) {
      pip_by <- setNames(as.numeric(meta$pipLocation), meta$name)
    }
    
    for (instr0 in instruments) {
      instr <- as_instr(instr0)
      
      j <- tryCatch(.get_candles(instr, granularity = granularity, count = count, price = "BA"),
                    error = function(e) NULL)
      
      use_mid <- FALSE
      if (is.null(j) || is.null(j$candles) ||
          !is.list(j$candles) || !all(c("bid","ask") %in% names(j$candles))) {
        j <- tryCatch(.get_candles(instr, granularity = granularity, count = count, price = "M"),
                      error = function(e) NULL)
        use_mid <- !is.null(j) && !is.null(j$candles) && "mid" %in% names(j$candles)
        if (!use_mid) next
      }
      
      parts <- strsplit(instr, "_", fixed = TRUE)[[1]]
      pair  <- paste(parts[1], parts[2], sep = "/")
      
      half_spread <- 0.0
      if (use_mid) {
        if (!is.null(pip_by) && !is.na(pip_by[instr])) {
          half_spread <- 0.5 * 10^(as.numeric(pip_by[instr]))  # 0.5 pip
        } else {
          half_spread <- getOption("oanda.mid_default_half_spread", 0.00005)
        }
      }
      
      if (use_mid) {
        mid <- suppressWarnings(as.numeric(j$candles$mid$c))
        tm  <- as.POSIXct(j$candles$time, tz = "UTC")
        ok  <- which(is.finite(mid))
        if (length(ok)) {
          rows[[length(rows) + 1]] <- data.frame(
            pair = pair,
            bid  = mid[ok] - half_spread,
            ask  = mid[ok] + half_spread,
            time = tm[ok],
            stringsAsFactors = FALSE
          )
        }
      } else {
        bid <- suppressWarnings(as.numeric(j$candles$bid$c))
        ask <- suppressWarnings(as.numeric(j$candles$ask$c))
        tm  <- as.POSIXct(j$candles$time, tz = "UTC")
        ok  <- which(is.finite(bid) & is.finite(ask))
        if (length(ok)) {
          rows[[length(rows) + 1]] <- data.frame(
            pair = pair, bid = bid[ok], ask = ask[ok], time = tm[ok],
            stringsAsFactors = FALSE
          )
        }
      }
    }
    
    if (length(rows)) dplyr::bind_rows(rows) else
      data.frame(pair = character(), bid = numeric(), ask = numeric(),
                 time = as.POSIXct(character()), stringsAsFactors = FALSE)
  }
  
  # ==============================
  # üì∏ Snapshot
  # ==============================
  snapshot <- function(instruments) {
    .check_cfg()
    if (!length(instruments)) {
      return(data.frame(pair = character(), bid = numeric(), ask = numeric(),
                        time = character(), stringsAsFactors = FALSE))
    }
    
    # pricing endpoint expects comma-separated instrument names; use underscore
    instruments <- vapply(instruments, as_instr, character(1))
    instr_csv <- paste(instruments, collapse = ",")
    
    url  <- sprintf("%s/accounts/%s/pricing", base_url_f(), account_id_f())
    resp <- .req_base(url) |>
      httr2::req_url_query(instruments = instr_csv) |>
      httr2::req_perform()
    httr2::resp_check_status(resp)
    
    j <- httr2::resp_body_json(resp, simplifyVector = FALSE)
    if (is.null(j$prices) || !length(j$prices)) {
      return(data.frame(pair = character(), bid = numeric(), ask = numeric(),
                        time = character(), stringsAsFactors = FALSE))
    }
    
    rows <- lapply(j$prices, function(q) {
      pair <- normalize_symbol(q$instrument)  # q$instrument is underscore
      bidv <- .last_price(q$bids)
      askv <- .last_price(q$asks)
      tm   <- if (!is.null(q$time)) as.POSIXct(q$time, tz = "UTC") else NA
      data.frame(pair = pair, bid = bidv, ask = askv, time = tm, stringsAsFactors = FALSE)
    })
    dplyr::bind_rows(rows)
  }
  
  # ==============================
  # üì° Live streaming
  # ==============================
  stream_prices <- function(instruments,
                            on_tick,
                            include_heartbeats = getOption("arb.stream.include_heartbeats", TRUE),
                            verbose            = getOption("arb.stream.verbose", TRUE),
                            snapshot           = getOption("arb.stream.snapshot", TRUE)) {
    .check_cfg()
    stopifnot(is.function(on_tick))
    if (!length(instruments)) stop("stream_prices(): empty instruments vector", call. = FALSE)
    
    # stream expects underscore instruments
    instruments <- vapply(instruments, as_instr, character(1))
    instr_csv <- paste(instruments, collapse = ",")
    
    base <- sprintf("%s/accounts/%s/pricing/stream", stream_base_url_f(), account_id_f())
    url  <- paste0(
      base,
      "?instruments=", utils::URLencode(instr_csv, reserved = TRUE),
      if (isTRUE(snapshot)) "&snapshot=true" else ""
    )
    
    ua_stream <- getOption("arb.user_agent_stream", getOption("arb.user_agent", "tri-fx-arb/0.1 (R curl)"))
    accept_encoding <- getOption("oanda.stream.accept_encoding", "identity")
    
    headers <- c(
      Authorization = paste("Bearer", api_token_f()),
      Accept        = "application/json",
      "User-Agent"  = ua_stream
    )
    
    attempt <- 0L
    repeat {
      attempt <- attempt + 1L
      if (isTRUE(verbose)) message(sprintf("üì° stream connect attempt #%d ‚Ä¶", attempt))
      
      h <- curl::new_handle(verbose = isTRUE(verbose))
      curl::handle_setheaders(h, .list = as.list(headers))
      curl::handle_setopt(h, accept_encoding = accept_encoding)
      
      got_any <- FALSE
      buf <- raw(0)
      
      handler <- function(x) {
        if (!length(x)) return(length(x))
        buf <<- c(buf, x)
        txt <- rawToChar(buf)
        
        lines <- strsplit(txt, "\n", fixed = TRUE)[[1]]
        complete <- lines
        remainder <- raw(0)
        
        if (nchar(txt) == 0L || substr(txt, nchar(txt), nchar(txt)) != "\n") {
          if (length(lines)) complete <- head(lines, -1)
          remainder <- charToRaw(if (length(lines)) tail(lines, 1) else "")
        }
        buf <<- remainder
        
        for (ln in complete) {
          ln <- trimws(ln)
          if (!nzchar(ln)) next
          
          j <- try(jsonlite::fromJSON(ln, simplifyVector = FALSE), silent = TRUE)
          if (inherits(j, "try-error")) next
          
          if (!is.null(j$type) && j$type %in% c("HEARTBEAT", "pricing.heartbeat")) {
            if (include_heartbeats && isTRUE(verbose) && !is.null(j$time)) {
              message("üíì ", j$time)
            }
            next
          }
          
          if (!is.null(j$type) && j$type %in% c("PRICE", "pricing.clientprice")) {
            bid <- .last_price(j$bids)
            ask <- .last_price(j$asks)
            if (is.finite(bid) && is.finite(ask)) {
              got_any <<- TRUE
              # j$instrument comes underscore; keep it as-is (core_runtime handles both)
              on_tick(j$instrument, bid, ask, time = j$time)
            } else if (isTRUE(verbose)) {
              message("‚ö†Ô∏è non-finite bid/ask; instrument: ", j$instrument)
            }
          } else if (isTRUE(verbose)) {
            message("‚ö†Ô∏è unexpected object type from stream: ", paste(class(j), collapse = "+"))
          }
        }
        length(x)
      }
      
      ok <- TRUE
      tryCatch(
        curl::curl_fetch_stream(url = url, handle = h, fun = handler),
        error = function(e) {
          ok <<- FALSE
          if (isTRUE(verbose)) message("‚ö†Ô∏è stream error: ", conditionMessage(e))
        }
      )
      
      if (isTRUE(verbose)) {
        if (ok) message("‚ÑπÔ∏è stream closed by server.")
        if (!got_any) message("‚ÑπÔ∏è no data received before close.")
      }
      
      delay <- min(30, 1 * 2^(attempt - 1L))
      Sys.sleep(delay)
    }
    
    invisible(TRUE)
  }
  
  # ==============================
  # üßæ Orders / account
  # ==============================
  place_market <- function(instrument, side = c("buy", "sell"), units) {
    .check_cfg()
    side <- match.arg(side)
    stopifnot(is.numeric(units), is.finite(units), units > 0)
    
    instrument <- as_instr(instrument)  # <--- normalization (path-safe)
    u <- if (side == "buy") units else -units
    tif <- getOption("oanda.order.time_in_force", "FOK")
    
    url  <- sprintf("%s/accounts/%s/orders", base_url_f(), account_id_f())
    body <- list(order = list(
      type        = "MARKET",
      instrument  = instrument,
      units       = as.character(u),
      timeInForce = tif
    ))
    
    resp <- .req_base(url) |>
      httr2::req_method("POST") |>
      httr2::req_body_json(body, auto_unbox = TRUE) |>
      httr2::req_perform()
    
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)
  }
  
  list_open_orders <- function() {
    .check_cfg()
    url <- sprintf("%s/accounts/%s/openOrders", base_url_f(), account_id_f())
    resp <- .req_base(url) |> httr2::req_perform()
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)$orders
  }
  
  account_summary <- function() {
    .check_cfg()
    url <- sprintf("%s/accounts/%s/summary", base_url_f(), account_id_f())
    resp <- .req_base(url) |> httr2::req_perform()
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)$account
  }
  
  # ==============================
  # üìö OrderBook / PositionBook (path-safe)
  # ==============================
  orderbook <- function(instrument, time = NULL) {
    .check_cfg()
    instrument <- as_instr(instrument)  # <--- critical fix (URL path-safe)
    url <- sprintf("%s/instruments/%s/orderBook", base_url_f(), instrument)
    req <- .req_base(url)
    if (!is.null(time)) req <- httr2::req_url_query(req, time = time)
    resp <- httr2::req_perform(req)
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)
  }
  
  positionbook <- function(instrument, time = NULL) {
    .check_cfg()
    instrument <- as_instr(instrument)  # <--- critical fix (URL path-safe)
    url <- sprintf("%s/instruments/%s/positionBook", base_url_f(), instrument)
    req <- .req_base(url)
    if (!is.null(time)) req <- httr2::req_url_query(req, time = time)
    resp <- httr2::req_perform(req)
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)
  }
  
  # ==============================
  # üßæ Info
  # ==============================
  describe <- function() {
    list(
      base_url        = base_url_f(),
      stream_base_url = stream_base_url_f(),
      account_id      = account_id_f(),
      has_auth        = has_auth()
    )
  }
  
  # ==============================
  # üì¶ Export DS object
  # ==============================
  list(
    provider               = "oanda-practice",
    
    base_url               = base_url_f,
    stream_base_url        = stream_base_url_f,
    
    base_url_value         = base_url_f(),
    stream_base_url_value  = stream_base_url_f(),
    
    api_token              = api_token_f,
    account_id             = account_id_f,
    
    has_auth               = has_auth,
    version                = "tri-fx-arb DS 0.3",
    
    normalize_symbol       = normalize_symbol,
    denorm_symbol          = denorm_symbol,
    
    ping                   = ping,
    list_symbols           = list_symbols,
    instruments_meta       = instruments_meta,
    fetch_history          = fetch_history,
    snapshot               = snapshot,
    stream_prices          = stream_prices,
    
    place_market           = place_market,
    list_open_orders       = list_open_orders,
    account_summary        = account_summary,
    
    orderbook              = orderbook,
    positionbook           = positionbook,
    
    describe               = describe
  )
})



DS$get_server_time <- function() {
  resp <- .oanda_get("/v3/accounts")
  
  if (is.null(resp$lastTransactionID)) {
    return(NULL)
  }
  
  list(
    time = Sys.time(), 
    server = resp$lastTransactionID
  )
}


==========================================================
üìÑ DirectStream.R
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/R/DirectStream.R
==========================================================
DS <- local({
  ## ---------- sm√• helpers ----------
  # ==============================
  # üîê OANDA Auth-konfig
  # ==============================
  # Leser autentiseringsdetaljer fra:
  # 1. R options() (dersom du har satt dem via options(oanda.account_id=...))
  # 2. Ellers milj√∏variabler i ~/.Renviron eller .env
  # 3. Har fallback p√• standard API-url (OANDA Practice)
  # ==============================
  # --- OANDA base URLs & auth helpers ---
  `%||%` <- function(x, y) {
    if (is.null(x)) y else x
  }
  stream_base_url_f <- function() {
    getOption(
      "oanda.stream_base_url",
      Sys.getenv("OANDA_STREAM_BASE_URL", "https://stream-fxpractice.oanda.com/v3")
    )
  }
  
  base_url_f <- function() {
    getOption(
      "oanda.base_url",
      Sys.getenv("OANDA_BASE_URL", "https://api-fxpractice.oanda.com/v3")
    )
  }
  
  api_token_f <- function() {
    getOption(
      "OANDA.API_KEY",
      Sys.getenv("OANDA_API_KEY", "")
    )
  }
  
  account_id_f <- function() {
    trimws(
      getOption(
        "oanda.account_id",
        Sys.getenv("OANDA_ACCOUNT_ID", "")
      )
    )
  }
  
  normalize_symbol <- function(sym) gsub("_","/", sym, fixed = TRUE)
  denorm_symbol    <- function(pair) gsub("/","_", pair, fixed = TRUE)
  
  .check_cfg <- function(){
    if (!nzchar(api_token_f()))  stop("OANDA api_key mangler. Sett options(OANDA.API_KEY='...') eller OANDA_API_KEY.", call.=FALSE)
    if (!nzchar(account_id_f())) stop("OANDA account_id mangler. Sett options(oanda.account_id='...') eller OANDA_ACCOUNT_ID.", call.=FALSE)
    if (!grepl("^https?://", base_url_f()))        stop("base_url ser rar ut: ",        base_url_f(),        call.=FALSE)
    if (!grepl("^https?://", stream_base_url_f())) stop("stream_base_url ser rar ut: ", stream_base_url_f(), call.=FALSE)
    invisible(TRUE)
  }
  
  has_auth <- function() {
    nzchar(api_token_f()) && nzchar(account_id_f())
  }
  
  ## felles request-builder
  .req_base <- function(url) {
    httr2::request(url) |>
      httr2::req_headers(
        Authorization = paste("Bearer", api_token_f()),
        Accept        = "application/json",
        `User-Agent`  = "tri-fx-arb/0.1 (R httr2)"
      ) |>
      httr2::req_timeout(30) |>
      httr2::req_retry(max_tries = 4, backoff = ~ runif(1, 0.4, 1.2) * (2^(.x-1)))
  }
  
  ## trygg uthenting av siste pris uansett struktur
  .last_price <- function(x) {
    if (is.null(x) || length(x) == 0) return(NA_real_)
    # Liste av lister: ta siste element og hent $price hvis finnes
    if (is.list(x) && !is.data.frame(x)) {
      last <- x[[length(x)]]
      if (is.list(last) && !is.null(last$price)) {
        return(suppressWarnings(as.numeric(last$price)))
      }
      # Hvis elementet i seg selv er atomisk, pr√∏v √• tolke som tall
      return(suppressWarnings(as.numeric(last)))
    }
    # Data.frame med kolonne "price"
    if (is.data.frame(x) && "price" %in% names(x)) {
      return(suppressWarnings(as.numeric(utils::tail(x$price, 1))))
    }
    # Atomisk vektor
    suppressWarnings(as.numeric(utils::tail(x, 1)))
  }
  
  ## ---------- konto/instrument ----------
  ping <- function(){
    .check_cfg()
    url  <- sprintf("%s/accounts/%s/summary", base_url_f(), account_id_f())
    resp <- .req_base(url) |>
      httr2::req_error(is_error = function(resp) FALSE) |>
      httr2::req_perform()
    cat("HTTP", httr2::resp_status(resp), httr2::resp_status_desc(resp), "\n")
    body <- httr2::resp_body_string(resp); if (nzchar(body)) cat(body, "\n")
    invisible(resp)
  }
  
  list_symbols <- function(){
    .check_cfg()
    url  <- sprintf("%s/accounts/%s/instruments", base_url_f(), account_id_f())
    resp <- .req_base(url) |> httr2::req_perform(); httr2::resp_check_status(resp)
    j    <- jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)
    syms <- j$instruments
    out  <- syms$name[syms$type == "CURRENCY" & grepl("^[A-Z]{3}_[A-Z]{3}$", syms$name)]
    as.character(sort(unique(out)))
  }
  
  instruments_meta <- function(){
    .check_cfg()
    url  <- sprintf("%s/accounts/%s/instruments", base_url_f(), account_id_f())
    resp <- .req_base(url) |> httr2::req_perform(); httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)$instruments
  }
  
  .get_candles <- function(instr, granularity="M1", count=10, price="BA"){
    url  <- sprintf("%s/instruments/%s/candles", base_url_f(), instr)
    resp <- .req_base(url) |>
      httr2::req_url_query(granularity = granularity, count = count, price = price) |>
      httr2::req_perform()
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)
  }
  
  fetch_history <- function(instruments, granularity="M1", count=10){
    rows <- list()
    meta <- try(instruments_meta(), silent = TRUE)
    pip_by <- NULL
    if (!inherits(meta, "try-error") && is.data.frame(meta)) {
      pip_by <- setNames(as.numeric(meta$pipLocation), meta$name)
    }
    
    for (instr in instruments){
      j <- tryCatch(.get_candles(instr, granularity=granularity, count=count, price="BA"),
                    error=function(e) NULL)
      use_mid <- FALSE
      if (is.null(j) || is.null(j$candles) ||
          !is.list(j$candles) || !all(c("bid","ask") %in% names(j$candles))) {
        j <- tryCatch(.get_candles(instr, granularity=granularity, count=count, price="M"),
                      error=function(e) NULL)
        use_mid <- !is.null(j) && !is.null(j$candles) && "mid" %in% names(j$candles)
        if (!use_mid) next
      }
      parts <- strsplit(instr, "_", fixed=TRUE)[[1]]
      pair  <- paste(parts[1], parts[2], sep="/")
      
      half_spread <- 0.0
      if (use_mid) {
        if (!is.null(pip_by) && !is.na(pip_by[instr])) {
          half_spread <- 0.5 * 10^(as.numeric(pip_by[instr]))  # 0.5 pip
        } else {
          half_spread <- 0.00005
        }
      }
      
      if (use_mid){
        mid <- suppressWarnings(as.numeric(j$candles$mid$c))
        tm  <- as.POSIXct(j$candles$time, tz = "UTC")
        ok  <- which(is.finite(mid))
        if (length(ok)){
          rows[[length(rows)+1]] <- data.frame(
            pair = pair,
            bid  = mid[ok] - half_spread,
            ask  = mid[ok] + half_spread,
            time = tm[ok],
            stringsAsFactors = FALSE
          )
        }
      } else {
        bid <- suppressWarnings(as.numeric(j$candles$bid$c))
        ask <- suppressWarnings(as.numeric(j$candles$ask$c))
        tm  <- as.POSIXct(j$candles$time, tz = "UTC")
        ok  <- which(is.finite(bid) & is.finite(ask))
        if (length(ok)){
          rows[[length(rows)+1]] <- data.frame(
            pair = pair, bid = bid[ok], ask = ask[ok], time = tm[ok],
            stringsAsFactors = FALSE
          )
        }
      }
    }
    if (length(rows)) dplyr::bind_rows(rows) else
      data.frame(pair=character(), bid=numeric(), ask=numeric(), time=as.POSIXct(character()))
  }
  
  ## ---------- live pricing ----------
  snapshot <- function(instruments){
    .check_cfg()
    if (!length(instruments)) {
      return(data.frame(pair=character(), bid=numeric(), ask=numeric(), time=character(), stringsAsFactors = FALSE))
    }
    instr_csv <- paste(instruments, collapse = ",")
    url  <- sprintf("%s/accounts/%s/pricing", base_url_f(), account_id_f())
    resp <- .req_base(url) |>
      httr2::req_url_query(instruments = instr_csv) |>
      httr2::req_perform()
    httr2::resp_check_status(resp)
    
    # Viktig: IKKE flatten automatisk
    j <- httr2::resp_body_json(resp, simplifyVector = FALSE)
    
    if (is.null(j$prices) || !length(j$prices)) {
      return(data.frame(pair=character(), bid=numeric(), ask=numeric(), time=character(), stringsAsFactors = FALSE))
    }
    
    rows <- lapply(j$prices, function(q) {
      pair <- normalize_symbol(q$instrument)
      bidv <- .last_price(q$bids)
      askv <- .last_price(q$asks)
      tm   <- if (!is.null(q$time)) as.POSIXct(q$time, tz = "UTC") else NA
      data.frame(pair = pair, bid = bidv, ask = askv, time = tm, stringsAsFactors = FALSE)
    })
    dplyr::bind_rows(rows)
  }
  
  stream_prices <- function(instruments,
                            on_tick,
                            include_heartbeats = FALSE,
                            verbose = FALSE,
                            snapshot = TRUE) {   # <‚Äî NEW
    .check_cfg(); stopifnot(is.function(on_tick))
    if (!length(instruments)) stop("stream_prices(): empty instruments vector", call. = FALSE)
    
    if (length(instruments) > 100L) {
      stop(sprintf("OANDA stream: maks 50 instrumenter per stream. Fikk %d.", length(instruments)), call. = FALSE)
    }
    
    instr_csv <- paste(instruments, collapse = ",")
    base <- sprintf("%s/accounts/%s/pricing/stream", stream_base_url_f(), account_id_f())
    url  <- paste0(
      base,
      "?instruments=", utils::URLencode(instr_csv, reserved = TRUE),
      if (isTRUE(snapshot)) "&snapshot=true" else ""
    )
    
    
    # NB: character-vektor (ikke list)
    headers <- c(
      Authorization = paste("Bearer", api_token_f()),
      Accept        = "application/json",
      "User-Agent"  = "tri-fx-arb/0.1 (R curl)"
    )
    
    attempt <- 0L
    repeat {
      attempt <- attempt + 1L
      if (verbose) message(sprintf("üì° stream connect attempt #%d ‚Ä¶", attempt))
      
      h <- curl::new_handle(verbose = isTRUE(verbose))
      curl::handle_setheaders(h, .list = as.list(headers))
      curl::handle_setopt(h, accept_encoding = "identity")
      # ev. sl√• av komprimering:
      # curl::handle_setopt(h, accept_encoding = "identity")
      
      got_any <- FALSE
      
      handler <- function(x) {
        if (!length(x)) return()
        txt <- rawToChar(x)
        for (ln in strsplit(txt, "\n", fixed = TRUE)[[1]]) {
          ln <- trimws(ln); if (!nzchar(ln)) next
          
          j <- try(jsonlite::fromJSON(ln, simplifyVector = FALSE), silent = TRUE)
          if (inherits(j, "try-error")) next
          
          # heartbeats
          if (!is.null(j$type) && j$type == "HEARTBEAT") {
            if (include_heartbeats && isTRUE(verbose) && !is.null(j$time)) {
              message("üíì ", j$time)
            }
            next
          }
          
          # prices
          if (is.list(j) && !is.null(j$type) && j$type == "PRICE") {
            bid <- .last_price(j$bids)
            ask <- .last_price(j$asks)
            if (is.finite(bid) && is.finite(ask)) {
              got_any <<- TRUE
              on_tick(j$instrument, bid, ask, time = j$time) 
            } else if (verbose) {
              message("‚ö†Ô∏è non-finite bid/ask; instrument: ", j$instrument)
            }
          } else if (verbose) {
            message("‚ö†Ô∏è unexpected object type from stream: ", paste(class(j), collapse = "+"))
            message("‚ö†Ô∏è problematic data: ", ln)
          }
        } # <- slutt for-l√∏kke
      } # <- slutt handler
      
      ok <- TRUE
      tryCatch(
        curl::curl_fetch_stream(url = url, handle = h, fun = handler),
        error = function(e) {
          ok <<- FALSE
          if (verbose) message("‚ö†Ô∏è stream error: ", conditionMessage(e))
        }
      )
      
      if (verbose) {
        if (ok) message("‚ÑπÔ∏è stream closed by server.")
        if (!got_any) message("‚ÑπÔ∏è no data received before close.")
      }
      
      # eksponentiell backoff (maks 30s)
      delay <- min(30, 1 * 2^(attempt - 1))
      Sys.sleep(delay)
    }
    
    invisible(TRUE)
  }
  
  
  ## ---------- ordre/endepunkter ----------
  
  
  
  place_market <- function(instrument, side = c("buy","sell"), units){
    .check_cfg()
    side <- match.arg(side)
    stopifnot(is.numeric(units), is.finite(units), units > 0)
    u <- if (side == "buy") units else -units
    
    url  <- sprintf("%s/accounts/%s/orders", base_url_f(), account_id_f())
    body <- list(order = list(
      type        = "MARKET",
      instrument  = instrument,
      units       = as.character(u),
      timeInForce = "FOK"  # eller "IOC"
    ))
    resp <- .req_base(url) |>
      httr2::req_method("POST") |>
      httr2::req_body_json(body, auto_unbox = TRUE) |>
      httr2::req_perform()
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)
  }
  
  list_open_orders <- function(){
    .check_cfg()
    url <- sprintf("%s/accounts/%s/openOrders", base_url_f(), account_id_f())
    resp <- .req_base(url) |> httr2::req_perform()
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)$orders
  }
  
  account_summary <- function(){
    .check_cfg()
    url <- sprintf("%s/accounts/%s/summary", base_url_f(), account_id_f())
    resp <- .req_base(url) |> httr2::req_perform()
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)$account
  }
  
  ## ---------- aggregert kundedata ----------
  orderbook <- function(instrument, time = NULL){
    .check_cfg()
    url <- sprintf("%s/instruments/%s/orderBook", base_url_f(), instrument)
    req <- .req_base(url)
    if (!is.null(time)) req <- httr2::req_url_query(req, time = time)
    resp <- httr2::req_perform(req)
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)
  }
  
  positionbook <- function(instrument, time = NULL){
    .check_cfg()
    url <- sprintf("%s/instruments/%s/positionBook", base_url_f(), instrument)
    req <- .req_base(url)
    if (!is.null(time)) req <- httr2::req_url_query(req, time = time)
    resp <- httr2::req_perform(req)
    httr2::resp_check_status(resp)
    jsonlite::fromJSON(httr2::resp_body_string(resp), simplifyVector = TRUE)
  }
  
  ## ---------- eksponer API ----------
  
  # liten helper som ikke printer n√∏kkelverdier
  describe <- function() {
    list(
      base_url        = base_url_f(),
      stream_base_url = stream_base_url_f(),
      account_id      = account_id_f(),
      has_auth        = has_auth()
    )
  }
  
  list(
    provider               = "oanda-practice",
    
    # funcs (kalles som DS$base_url(), DS$stream_base_url())
    base_url               = base_url_f,
    stream_base_url        = stream_base_url_f,
    
    # ferdig evaluerte verdier (til rask inspeksjon)
    base_url_value         = base_url_f(),
    stream_base_url_value  = stream_base_url_f(),
    
    # identifikatorer (NB: ikke print DS$api_token() i konsollen)
    api_token              = api_token_f,
    account_id             = account_id_f,
    
    # kjapp auth-sjekk
    has_auth               = has_auth,
    
    # valgfri versjon/info
    version                = "tri-fx-arb DS 0.2",
    
    # dine eksisterende exports
    normalize_symbol       = normalize_symbol,
    denorm_symbol          = denorm_symbol,
    ping                   = ping,
    list_symbols           = list_symbols,
    instruments_meta       = instruments_meta,
    fetch_history          = fetch_history,
    snapshot               = snapshot,
    stream_prices          = stream_prices,
    place_market           = place_market,
    list_open_orders       = list_open_orders,
    account_summary        = account_summary,
    orderbook              = orderbook,
    positionbook           = positionbook,
    
    # oversikt
    describe               = describe
  )
})# <-- Viktig: avslutter DS <- local({ ... }) med "})"



==========================================================
üìÑ engine_bindings.R
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/R/engine_bindings.R
==========================================================
# ============================
# engine_bindings.R ‚Äî FINAL FIX
# ============================

engine_load <- function(path) {
  if (!is.loaded("engine_create")) {
    dyn.load(path)
    message("Loaded engine dylib: ", path)
  }
}

# --------------------------------------------------------
# TRI-rute-generator
# --------------------------------------------------------
#build_tri_routes <- function(ccys, start_ccy) {
  s <- match(start_ccy, ccys)
  idx <- setdiff(seq_along(ccys), s)
  
  g <- expand.grid(mid = idx, end = idx)
  g <- g[g$mid != g$end, ]
  
  routes <- as.matrix(g)
  storage.mode(routes) <- "integer"
  routes
}

# --------------------------------------------------------
# engine_create ‚Üí matcher C signatur 1:1
# --------------------------------------------------------
engine_create <- function(ccys) {
  start_ccy <- getOption("arb.start_ccy", "USD")
  
  routes <- build_tri_routes(ccys, start_ccy)
  
  start_index <- match(start_ccy, ccys)
  if (is.na(start_index)) start_index <- 1L
  
  .Call("engine_create",
        routes,
        as.integer(start_index),
        as.integer(length(ccys)))
}

# --------------------------------------------------------
# R wrappers
# --------------------------------------------------------
engine_start <- function(ptr) {
  .Call("engine_start_R", ptr)
}

engine_stop <- function(ptr) {
  .Call("engine_stop_R", ptr)
}

engine_push_tick <- function(ptr, i, j, bid, ask) {
  .Call("engine_push_tick_R",
        ptr,
        as.integer(i),
        as.integer(j),
        as.numeric(bid),
        as.numeric(ask))
}

engine_poll <- function(ptr) {
  .Call("engine_poll", ptr)
}




.engine_push_mats <- function(eng, state) {
  for (i in seq_len(nrow(state$M))) {
    for (j in seq_len(ncol(state$M))) {
      bid <- state$BID[i,j]
      ask <- state$ASK[i,j]
      if (is.finite(bid) && is.finite(ask) && bid > 0 && ask > 0) {
        .Call("engine_push_tick_R", eng, i, j, bid, ask)
      }
    }
  }
  invisible(TRUE)
  
  
  
  
  
  
  
  
  
  
  
  # ============================================================
  #  ENGINE WRAPPER FOR ENGINE v4 (TRI + CYCLE)
  #  Komplett, korrekt og matchet til C-koden du ga meg
  # ============================================================
  
  # -----------------------------
  # Load the shared library
  # -----------------------------
  engine_load <- function(path) {
    path <- normalizePath(path, mustWork = TRUE)
    dyn.load(path)
    invisible(TRUE)
  }
  
  # -----------------------------
  # Create engine
  # -----------------------------
  engine_create <- function(routes_matrix, start_ccy_index, n_ccy) {
    stopifnot(is.matrix(routes_matrix))
    stopifnot(is.integer(routes_matrix))
    stopifnot(length(start_ccy_index) == 1L)
    stopifnot(length(n_ccy) == 1L)
    
    .Call(
      "engine_create",
      routes_matrix,
      as.integer(start_ccy_index),
      as.integer(n_ccy)
    )
  }
  
  # -----------------------------
  # Start engine thread
  # -----------------------------
  engine_start <- function(ptr) {
    .Call("engine_start_R", ptr)
  }
  
  # -----------------------------
  # Stop engine
  # -----------------------------
  engine_stop <- function(ptr) {
    .Call("engine_stop_R", ptr)
  }
  
  # -----------------------------
  # Push a single tick
  # -----------------------------
  engine_push_tick <- function(ptr, i, j, bid, ask) {
    .Call(
      "engine_push_tick_R",
      ptr,
      as.integer(i),
      as.integer(j),
      as.numeric(bid),
      as.numeric(ask)
    )
  }
  
  # -----------------------------
  # Fill engine with full matrix
  # -----------------------------
  engine_push_full <- function(ptr, M, BID, ASK) {
    n <- nrow(M)
    for (i in seq_len(n)) {
      for (j in seq_len(n)) {
        b <- BID[i, j]
        a <- ASK[i, j]
        if (is.finite(b) && is.finite(a) && b > 0 && a > 0) {
          engine_push_tick(ptr, i, j, b, a)
        }
      }
    }
    invisible(TRUE)
  }
  
  # -----------------------------
  # Poll all results at once
  # -----------------------------
  engine_poll <- function(ptr) {
    .Call("engine_poll", ptr)
  }
  
  # -----------------------------
  # Helper: build TRI routes
  # (1-based mid/end)
  # -----------------------------
  build_tri_routes <- function(ccys, start_ccy) {
    s <- match(start_ccy, ccys)
    idx <- setdiff(seq_along(ccys), s)
    
    g <- expand.grid(mid = idx, end = idx)
    g <- g[g$mid != g$end, ]
    
    routes <- as.matrix(g)
    storage.mode(routes) <- "integer"
    routes
  }
  
  # -----------------------------
  # Full initializer
  # (state$ccys, state$M/BID/ASK already exist)
  # -----------------------------
  engine_init <- function(state, start_ccy) {
    
    start_i <- match(start_ccy, state$ccys)
    if (is.na(start_i)) stop("start_ccy not in state$ccys")
    
    # Build triangular routes
    routes <- build_tri_routes(state$ccys, start_ccy)
    
    state$routes <- routes
    
    # Create engine in C
    state$eng <- engine_create(
      routes_matrix = routes, 
      start_ccy_index = start_i,
      n_ccy = length(state$ccys)
    )
    
    # Push initial matrices
    engine_push_full(state$eng, state$M, state$BID, state$ASK)
    
    # Start computation thread
    engine_start(state$eng)
    
    state
  }
}


==========================================================
üìÑ Engine_Wrapper.R
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/R/Engine_Wrapper.R
==========================================================
# ============================================================
#  ENGINE WRAPPER FOR ENGINE v4 (TRI + CYCLE)
#  Komplett, korrekt og matchet til C-koden du ga meg
# ============================================================

# -----------------------------
# Load the shared library
# -----------------------------
engine_load <- function(path) {
  path <- normalizePath(path, mustWork = TRUE)
  dyn.load(path)
  invisible(TRUE)
}



# -----------------------------
# Create engine (TRI + CYCLE)
# -----------------------------
engine_create <- function(routes_matrix, start_ccy_index, n_ccy) {
  stopifnot(is.matrix(routes_matrix))
  stopifnot(is.integer(routes_matrix))
  stopifnot(length(start_ccy_index) == 1L)
  stopifnot(length(n_ccy) == 1L)
  
  .Call(
    "engine_create",
    routes_matrix,
    as.integer(start_ccy_index),
    as.integer(n_ccy)
  )
}

# -----------------------------
# Start engine thread
# -----------------------------
engine_start <- function(ptr) {
  .Call("engine_start_R", ptr)
}


  
# -----------------------------
# Stop engine thread
# -----------------------------
engine_stop <- function(ptr) {
  .Call("engine_stop_R", ptr)
}

# -----------------------------
# Push a single tick
# -----------------------------
engine_push_tick <- function(ptr, i, j, bid, ask) {
  .Call(
    "engine_push_tick_R",
    ptr,
    as.integer(i),
    as.integer(j),
    as.numeric(bid),
    as.numeric(ask)
  )
}




# -----------------------------
# Push full BID/ASK matrix
# -----------------------------
engine_push_full <- function(ptr, M, BID, ASK) {
  n <- nrow(M)
  for (i in seq_len(n)) {
    for (j in seq_len(n)) {
      b <- BID[i, j]
      a <- ASK[i, j]
      if (is.finite(b) && is.finite(a) && b > 0 && a > 0) {
        engine_push_tick(ptr, i, j, b, a)
      }
    }
  }
  invisible(TRUE)
}

# -----------------------------
# Poll all results
# -----------------------------
engine_poll <- function(ptr) {
  .Call("engine_poll", ptr)
}


# -----------------------------
# Full initializer
# -----------------------------
engine_init <- function(state, start_ccy) {
  start_i <- match(start_ccy, state$ccys)
  if (is.na(start_i)) stop("start_ccy not in state$ccys")
  
  # Build TRI routes
  routes <- build_tri_routes(state$ccys, start_ccy)
  state$routes <- routes
  
  # Create engine in C
  state$eng <- engine_create(
    routes_matrix = routes,
    start_ccy_index = start_i,
    n_ccy = length(state$ccys)
  )
  
  # Fill matrix
  engine_push_full(state$eng, state$M, state$BID, state$ASK)
  
  # Start computation thread
  engine_start(state$eng)
  
  state
}


ns <- function() {
  # time in nanoseconds as integer64
  as.integer64(Sys.time())  # high-resolution
}












==========================================================
üìÑ Enginge_Bindings.R
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/R/Enginge_Bindings.R
==========================================================

engine_load <- function(path = file.path("C++", "build", "libengine_v4.dylib")) {
  path <- normalizePath(path, mustWork = TRUE)
  if (!is.loaded("engine_poll_R")) {
    dyn.load(path)
  }
  invisible(TRUE)
}


==========================================================
üìÑ Quote_Map_Preprocessor.R
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/R/Quote_Map_Preprocessor.R
==========================================================
# utils.R (engine-first minimal)
# ------------------------------
# Beholder kun sm√• generelle helpers + trigger/fee-formler
# Quote-map og matrise-bygging er fjernet (un√∏dvendig n√•r C++ engine eier matrisen).

#`%||%` <- function(x, y) if (is.null(x)) y else x

#tri_dbg <- function(fmt, ...) {
 # if (isTRUE(getOption("tri.debug", FALSE))) {
    #cat(sprintf(paste0("[DBG] ", fmt, "\n"), ...))
 # }
#}

#.is_fun <- function(fn) isTRUE(exists(fn, mode = "function"))

# --- Invers quote helper (nyttig n√•r du vil pushe begge retninger i on_tick) ---
#inv_bid_ask <- function(bid, ask) {
  #if (!is.finite(bid) || !is.finite(ask) || bid <= 0 || ask <= 0) {
    #return(c(bid = NA_real_, ask = NA_real_))
  #}
 # c(bid = 1 / ask, ask = 1 / bid)
#}

# ------- trigger/fee-formler --------------------------------------------------
#eff_fee_3legs <- function(fee_pct) {
#  if (.is_fun("eff_fee_3legs_cpp")) return(eff_fee_3legs_cpp(fee_pct))
 # 1 - (1 - fee_pct)^3
#}

#edge_trigger_threshold <- function(fee_pct, slip_frac, buffer_frac) {
 # if (.is_fun("edge_trigger_threshold_cpp")) {
  #  return(edge_trigger_threshold_cpp(fee_pct, slip_frac, buffer_frac))
  #}
  #eff_fee_3legs(fee_pct) + 3 * slip_frac + buffer_frac
#}

# ------- side_used (for logging/diagnose) ------------------------------------
# side: 0 = ask/inverse brukt, 1 = bid/direct brukt (matcher tri_pnl_cpp fallbacken din)
#side_used <- function(side, from_i, to_i, ccys, BID, ASK) {
 ## if (.is_fun("side_used_cpp")) return(side_used_cpp(side, from_i, to_i, ccys, BID, ASK))
  #if (is.na(side)) return(list(used = "none", px = NA_real_))
#  if (side == 0L) list(used = sprintf("ask %s/%s", ccys[to_i], ccys[from_i]), px = ASK[to_i, from_i])
 # else           list(used = sprintf("bid %s/%s", ccys[from_i], ccys[to_i]), px = BID[from_i, to_i])
#}


==========================================================
üìÑ trading_bot.R
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/R/trading_bot.R
==========================================================
# R/Trading_Bot.R (engine-first, execution-robust)
`%||%` <- function(x, y) if (is.null(x)) y else x

# ==============================
# Trade throttle / guards
# ==============================
.trd <- new.env(parent = emptyenv())
.trd$inflight <- FALSE
.trd$last_ts  <- as.numeric(Sys.time()) - 999
.trd$last_decision_ms <- 0

.trd_can_trade <- function(cooldown_sec) {
  now <- as.numeric(Sys.time())
  if (isTRUE(.trd$inflight)) return(FALSE)
  if ((now - .trd$last_ts) < cooldown_sec) return(FALSE)
  TRUE
}

# ==============================
# Instrument normalization
# ==============================
oanda_instr <- function(a, b) paste0(a, "_", b)
sym_to_pair <- function(sym) gsub("_", "/", sym, fixed = TRUE)
pair_to_sym <- function(pair) gsub("/", "_", pair, fixed = TRUE)

# ==============================
# State matrix helpers (for leg selection)
# ==============================
.ensure_idx_cache <- function(state) {
  if (!is.null(state$.idx)) return(invisible(state$.idx))
  ccys <- rownames(state$BID)
  idx <- seq_along(ccys); names(idx) <- ccys
  state$.idx <- idx
  invisible(idx)
}

.ij <- function(a, b, state) {
  .ensure_idx_cache(state)
  i <- state$.idx[[a]]; j <- state$.idx[[b]]
  if (is.null(i) || is.null(j)) return(c(NA_integer_, NA_integer_))
  c(as.integer(i), as.integer(j))
}

q_bid2 <- function(a, b, state) {
  ij <- .ij(a, b, state); if (any(is.na(ij))) return(NA_real_)
  v <- state$BID[ij[1], ij[2]]; if (is.finite(v)) v else NA_real_
}

q_ask2 <- function(a, b, state) {
  ij <- .ij(a, b, state); if (any(is.na(ij))) return(NA_real_)
  v <- state$ASK[ij[1], ij[2]]; if (is.finite(v)) v else NA_real_
}

# pick_leg: behold ditt valg-m√∏nster:
# - direkte quote (a/b) -> "sell" p√• bid
# - fallback inverse (b/a) -> "buy" p√• ask
pick_leg <- function(a, b, state) {
  bq <- q_bid2(a, b, state); aq <- q_ask2(a, b, state)
  if (is.finite(bq) && is.finite(aq)) {
    return(list(mode = "direct", instrument = oanda_instr(a, b), side = "sell", quote_price = bq))
  }
  bq2 <- q_bid2(b, a, state); aq2 <- q_ask2(b, a, state)
  if (is.finite(bq2) && is.finite(aq2)) {
    return(list(mode = "inverse", instrument = oanda_instr(b, a), side = "buy", quote_price = aq2))
  }
  NULL
}

# ==============================
# OANDA response parsing (robust)
# ==============================
.num <- function(x) suppressWarnings(as.numeric(x))

.parse_oanda_market_resp <- function(resp) {
  # Expected patterns:
  # - resp$orderFillTransaction
  # - resp$orderCancelTransaction
  # - resp$orderRejectTransaction
  if (is.null(resp) || !is.list(resp)) {
    return(list(ok = FALSE, filled = FALSE, reason = "NULL_OR_NONLIST_RESPONSE"))
  }
  
  fill <- resp$orderFillTransaction %||% NULL
  if (!is.null(fill) && is.list(fill)) {
    units_signed <- .num(fill$units)
    price        <- .num(fill$price)
    instrument   <- fill$instrument %||% (resp$orderCreateTransaction$instrument %||% NA_character_)
    time         <- fill$time %||% (resp$orderCreateTransaction$time %||% NA_character_)
    txid         <- fill$id %||% (resp$lastTransactionID %||% NA_character_)
    
    if (!is.finite(units_signed) || !is.finite(price) || price <= 0) {
      return(list(ok = FALSE, filled = FALSE, reason = "BAD_FILL_NUMBERS", raw = resp))
    }
    
    return(list(
      ok = TRUE,
      filled = TRUE,
      instrument = instrument,
      time = time,
      txid = txid,
      units_signed = units_signed,
      units = abs(units_signed),
      price = price,
      raw = resp
    ))
  }
  
  cancel <- resp$orderCancelTransaction %||% resp$orderRejectTransaction %||% resp$cancelTransaction %||% NULL
  if (!is.null(cancel) && is.list(cancel)) {
    reason <- cancel$reason %||% cancel$rejectReason %||% cancel$errorMessage %||% "ORDER_CANCEL_OR_REJECT"
    txid   <- cancel$id %||% (resp$lastTransactionID %||% NA_character_)
    return(list(ok = FALSE, filled = FALSE, reason = as.character(reason), txid = txid, raw = resp))
  }
  
  list(ok = FALSE, filled = FALSE, reason = "NO_FILL_FOUND", raw = resp)
}

# ==============================
# Leg planning + execution
# ==============================
TRD_MIN_UNITS <- as.integer(getOption("arb.min_units", 1L))

.plan_leg <- function(amount_from, from_ccy, to_ccy, state) {
  leg <- pick_leg(from_ccy, to_ccy, state)
  if (is.null(leg)) return(NULL)
  
  qpx <- leg$quote_price
  if (!is.finite(qpx) || qpx <= 0) return(NULL)
  if (!is.finite(amount_from) || amount_from <= 0) return(NULL)
  
  if (identical(leg$mode, "direct")) {
    # Sell base=from_ccy units
    units_req <- as.integer(floor(amount_from))
    if (!is.finite(units_req) || units_req < TRD_MIN_UNITS) return(NULL)
    expected_recv <- units_req * qpx
  } else {
    # Buy base=to_ccy units, pay in from_ccy
    units_req <- as.integer(floor(amount_from / qpx))
    if (!is.finite(units_req) || units_req < TRD_MIN_UNITS) return(NULL)
    
    # safety: do not exceed spend
    if ((units_req * qpx) > amount_from) return(NULL)
    
    expected_recv <- units_req
  }
  
  list(
    from = from_ccy, to = to_ccy,
    mode = leg$mode,
    instrument = leg$instrument,
    side = leg$side,
    quote_price = qpx,
    units_req = units_req,
    expected_recv = expected_recv
  )
}

# Best-effort unwind: motsatt side, samme instrument, samme filled base units
.unwind_leg <- function(exec, state) {
  if (is.null(exec) || !isTRUE(exec$filled)) return(FALSE)
  
  units <- as.integer(exec$units_fill)
  if (!is.finite(units) || units <= 0) return(FALSE)
  
  side2 <- if (identical(exec$side, "buy")) "sell" else "buy"
  
  resp <- tryCatch(
    state$DS$place_market(instrument = exec$instrument, side = side2, units = units),
    error = function(e) e
  )
  if (inherits(resp, "error")) return(FALSE)
  
  ufill <- .parse_oanda_market_resp(resp)
  isTRUE(ufill$ok) && isTRUE(ufill$filled)
}

# Core: place leg and compute recv_amount using true fills
.place_leg <- function(plan, state,
                       dry_run = isTRUE(getOption("arb.dry_run", FALSE)),
                       max_slip_bps = getOption("arb.max_slip_bps", Inf)) {
  stopifnot(is.list(plan), is.environment(state))
  
  units_req <- as.integer(plan$units_req)
  if (!is.finite(units_req) || units_req <= 0) {
    return(list(ok = FALSE, filled = FALSE, reason = "BAD_UNITS_REQ", plan = plan))
  }
  
  if (isTRUE(dry_run)) {
    # Simuler "perfekt fill" p√• quote_price
    units_fill  <- units_req
    fill_price  <- plan$quote_price
    recv_amount <- if (identical(plan$mode, "direct")) units_fill * fill_price else units_fill
    
    return(list(
      ok = TRUE, filled = TRUE, simulated = TRUE,
      instrument = plan$instrument, side = plan$side,
      from = plan$from, to = plan$to, mode = plan$mode,
      units_req = units_req, units_fill = units_fill,
      quote_price = plan$quote_price, fill_price = fill_price,
      recv_amount = recv_amount,
      txid = NA_character_, time = as.character(Sys.time()),
      reason = NULL
    ))
  }
  
  resp <- tryCatch(
    state$DS$place_market(instrument = plan$instrument, side = plan$side, units = units_req),
    error = function(e) e
  )
  if (inherits(resp, "error")) {
    return(list(ok = FALSE, filled = FALSE, reason = conditionMessage(resp), plan = plan))
  }
  
  fill <- .parse_oanda_market_resp(resp)
  if (!isTRUE(fill$ok) || !isTRUE(fill$filled)) {
    return(c(list(plan = plan), fill))
  }
  
  units_fill <- fill$units
  fill_price <- fill$price
  
  # recv_amount always in 'to' currency
  recv_amount <- if (identical(plan$mode, "direct")) {
    units_fill * fill_price
  } else {
    units_fill
  }
  
  # Slippage guard hook (optional)
  slip_ok <- TRUE
  max_slip_bps <- suppressWarnings(as.numeric(max_slip_bps))
  if (is.finite(max_slip_bps) && max_slip_bps >= 0) {
    tol <- max_slip_bps / 1e4
    if (identical(plan$side, "sell")) {
      slip_ok <- is.finite(fill_price) && (fill_price >= plan$quote_price * (1 - tol))
    } else {
      slip_ok <- is.finite(fill_price) && (fill_price <= plan$quote_price * (1 + tol))
    }
  }
  
  if (!isTRUE(slip_ok)) {
    return(list(
      ok = FALSE, filled = TRUE, reason = "SLIPPAGE_GUARD",
      instrument = plan$instrument, side = plan$side,
      from = plan$from, to = plan$to, mode = plan$mode,
      units_req = units_req, units_fill = units_fill,
      quote_price = plan$quote_price, fill_price = fill_price,
      recv_amount = recv_amount,
      txid = fill$txid %||% NA_character_, time = fill$time %||% NA_character_,
      raw = fill$raw %||% resp,
      plan = plan
    ))
  }
  
  list(
    ok = TRUE, filled = TRUE,
    instrument = plan$instrument, side = plan$side,
    from = plan$from, to = plan$to, mode = plan$mode,
    units_req = units_req, units_fill = units_fill,
    quote_price = plan$quote_price, fill_price = fill_price,
    recv_amount = recv_amount,
    txid = fill$txid %||% NA_character_, time = fill$time %||% NA_character_,
    raw = fill$raw %||% resp
  )
}

# ================================================================
# execute_route_v4()
# Triangular arbitrage execution for engine v4 routes
# ================================================================
execute_route_v4 <- function(state, route, notional, dry_run = TRUE) {
  # ------------------------------------------------------------
  # route = one row from engine_poll():
  # route$route_id
  # route$mid
  # route$end
  # ------------------------------------------------------------
  
  CC   <- state$ccys
  S    <- CC[ state$start_i ]   # always start currency (USD)
  MID  <- CC[ route$mid ]
  END  <- CC[ route$end ]
  
  # ------------------------------------------------------------
  # Step 1 ‚Äî Build instrument names (always OANDA format)
  # ------------------------------------------------------------
  pair1 <- paste0(S, "_", MID)   # S ‚Üí MID (buy MID)
  pair2 <- paste0(MID, "_", END) # MID ‚Üí END
  pair3 <- paste0(END, "_", S)   # END ‚Üí S (sell back to start)
  
  # ------------------------------------------------------------
  # Step 2 ‚Äî Fetch current prices (snapshot)
  # ------------------------------------------------------------
  px <- DS$snapshot(c(pair1, pair2, pair3))
  px1 <- px[ px$pair == gsub("_","/",pair1), ]
  px2 <- px[ px$pair == gsub("_","/",pair2), ]
  px3 <- px[ px$pair == gsub("_","/",pair3), ]
  
  if (nrow(px1)==0 || nrow(px2)==0 || nrow(px3)==0) {
    return(list(ok=FALSE, reason="missing_snapshot"))
  }
  
  # ------------------------------------------------------------
  # Step 3 ‚Äî Compute theoretical fills without slippage
  # ------------------------------------------------------------
  qty_mid <- notional / px1$ask
  qty_end <- qty_mid  / px2$ask
  final   <- qty_end  * px3$bid
  
  pnl <- final - notional
  edge <- final/notional - 1
  
  # ------------------------------------------------------------
  # Reject very small or negative edges
  # ------------------------------------------------------------
  if (edge < (getOption("arb.min_edge_bps") / 1e4))
    return(list(ok=FALSE, reason="edge_too_small", pnl=pnl, edge=edge))
  
  # ------------------------------------------------------------
  # Step 4 ‚Äî Liquidity gate (optional)
  # ------------------------------------------------------------
  if (isTRUE(getOption("arb.use_liquidity_gate", FALSE))) {
    # check orderbook volume on each leg
    ob1 <- DS$orderbook(pair1)
    ob2 <- DS$orderbook(pair2)
    ob3 <- DS$orderbook(pair3)
    
    if (!has_sufficient_liquidity(ob1, notional)) return(list(ok=FALSE, reason="no_liq_leg1"))
    if (!has_sufficient_liquidity(ob2, qty_mid))   return(list(ok=FALSE, reason="no_liq_leg2"))
    if (!has_sufficient_liquidity(ob3, qty_end))   return(list(ok=FALSE, reason="no_liq_leg3"))
  }
  
  # ------------------------------------------------------------
  # Step 5 ‚Äî DRY RUN (simulation only)
  # ------------------------------------------------------------
  if (dry_run) {
    return(list(
      ok     = TRUE,
      dry_run= TRUE,
      S=S, MID=MID, END=END,
      pnl=pnl, edge=edge,
      theoretical_final = final,
      qty_mid=qty_mid,
      qty_end=qty_end,
      px1=px1, px2=px2, px3=px3
    ))
  }
  
  # ------------------------------------------------------------
  # Step 6 ‚Äî Real execution (market orders)
  # ------------------------------------------------------------
  r1 <- DS$place_market(pair1, side="buy",  units = notional)
  if (is.null(r1)) return(list(ok=FALSE, where="leg1_fail"))
  
  r2 <- DS$place_market(pair2, side="buy",  units = qty_mid)
  if (is.null(r2)) {
    # rollback leg 1:
    DS$place_market(pair1, side="sell", units = notional)
    return(list(ok=FALSE, where="leg2_fail_rollback1"))
  }
  
  r3 <- DS$place_market(pair3, side="sell", units = qty_end)
  if (is.null(r3)) {
    # rollback leg 1 & 2:
    DS$place_market(pair2, side="sell", units = qty_mid)
    DS$place_market(pair1, side="sell", units = notional)
    return(list(ok=FALSE, where="leg3_fail_rollback12"))
  }
  
  # ------------------------------------------------------------
  # Step 7 ‚Äî Success
  # ------------------------------------------------------------
  return(list(
    ok=TRUE,
    S=S, MID=MID, END=END,
    route_id = route$route_id,
    pnl=pnl,
    edge=edge,
    final=final,
    orders = list(r1=r1, r2=r2, r3=r3)
  ))
}

# ==============================
# Engine decision (poll state$eng, robust columns, low-spam)
# ==============================
.colpick <- function(df, candidates) {
  for (nm in candidates) if (nm %in% names(df)) return(nm)
  NULL
}

maybe_trade_from_engine <- function(state,
                                    start_ccy = getOption("arb.start_ccy", "USD"),
                                    bankroll  = getOption("arb.bankroll", 10000)) {
  stopifnot(is.environment(state))
  
  # Decision throttle (ms)
  min_ms <- as.integer(getOption("arb.decision_min_interval_ms", 50L))
  now_ms <- as.numeric(Sys.time()) * 1000
  if (is.finite(.trd$last_decision_ms) && (now_ms - .trd$last_decision_ms) < min_ms) {
    return(invisible(FALSE))
  }
  .trd$last_decision_ms <- now_ms
  
  df <- engine_poll(state$eng)
  if (!is.data.frame(df) || !nrow(df)) return(invisible(FALSE))
  
  mid_col  <- .colpick(df, c("mid", "mid_i", "mid_idx"))
  end_col  <- .colpick(df, c("end", "end_i", "end_idx"))
  edge_col <- .colpick(df, c("edge", "edge_before_cost", "edgeRaw"))
  pnl_col  <- .colpick(df, c("pnl", "netPnL", "net_pnl", "pnl_abs"))
  
  if (is.null(mid_col) || is.null(end_col) || is.null(edge_col)) return(invisible(FALSE))
  
  df[[mid_col]]  <- suppressWarnings(as.integer(df[[mid_col]]))
  df[[end_col]]  <- suppressWarnings(as.integer(df[[end_col]]))
  df[[edge_col]] <- suppressWarnings(as.numeric(df[[edge_col]]))
  if (!is.null(pnl_col)) df[[pnl_col]] <- suppressWarnings(as.numeric(df[[pnl_col]]))
  
  df <- df[is.finite(df[[edge_col]]), , drop = FALSE]
  if (!nrow(df)) return(invisible(FALSE))
  
  # Require both edge and pnl (optional)
  min_edge_bps <- as.numeric(getOption("arb.min_edge_bps", 5))
  min_pnl      <- as.numeric(getOption("arb.min_pnl", 0))
  require_pnl  <- isTRUE(getOption("arb.require_positive_pnl", TRUE))
  
  # pick best edge
  k <- which.max(df[[edge_col]])
  edge_bps <- 1e4 * df[[edge_col]][k]
  
  pnl_ok <- TRUE
  pnl_val <- NA_real_
  if (!is.null(pnl_col) && is.finite(df[[pnl_col]][k])) {
    pnl_val <- df[[pnl_col]][k]
    if (require_pnl) pnl_ok <- (pnl_val >= min_pnl)
  } else if (require_pnl && min_pnl > 0) {
    pnl_ok <- FALSE
  }
  
  if (!is.finite(edge_bps) || edge_bps < min_edge_bps || !isTRUE(pnl_ok)) {
    # one-line decision log (optional)
    if (isTRUE(getOption("arb.print.decisions", FALSE))) {
      cat(sprintf("DECISION skip | edge=%.2f bps | pnl=%s\n",
                  edge_bps, ifelse(is.finite(pnl_val), sprintf("%.2f", pnl_val), "NA")))
    }
    return(invisible(FALSE))
  }
  
  mid_i <- df[[mid_col]][k]
  end_i <- df[[end_col]][k]
  if (!is.finite(mid_i) || !is.finite(end_i)) return(invisible(FALSE))
  
  mid <- state$ccys[[mid_i]]
  end <- state$ccys[[end_i]]
  if (is.na(mid) || is.na(end)) return(invisible(FALSE))
  
  notional <- min(as.numeric(bankroll), as.numeric(getOption("arb.max_notional_start", 25000)))
  
  # one-line decision log
  if (isTRUE(getOption("arb.print.decisions", TRUE))) {
    cat(sprintf("DECISION trade? %s->%s->%s->%s | edge=%.2f bps | pnl=%s | notional=%.0f\n",
                start_ccy, mid, end, start_ccy,
                edge_bps,
                ifelse(is.finite(pnl_val), sprintf("%.2f", pnl_val), "NA"),
                notional))
  }
  
  res <- execute_triangle(start_ccy, mid, end, notional, state = state)
  invisible(is.list(res) && isTRUE(res$ok))
}


==========================================================
üìÑ tradingrobot copy.R
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/R/tradingrobot copy.R
==========================================================
# R/trading_bot.R (C++ engine-first, clean)
# -----------------------------------------
# Trading bot with:
#  - Dynamic slippage from recent volatility (config via options)
#  - Sequential 3-leg execution with rollback/hedge attempts
#  - Fractional Kelly sizing (live via options)
#  - Error resilience + spread/liquidity gating
#  - Engine-first route screening (dirty-routing C++)
#  - ALL prints routed through arb.core_logger
# -----------------------------------------

`%||%` <- function(x, y) if (is.null(x)) y else x

# ===== Live config accessor (reads options each call) =========================
TRD_CFG <- function() {
  list(
    cooldown_sec = as.numeric(getOption("arb.cooldown_sec",        0.0)),
    dry_run      = isTRUE(getOption("arb.dry_run",                 TRUE)),
    frac_kelly   = as.numeric(getOption("arb.frac_kelly",          2e-04)),
    max_notional = as.numeric(getOption("arb.max_notional_start",  25000)),
    min_edge_bps = as.integer(getOption("arb.min_edge_bps",        5L)),
    min_units    = as.integer(getOption("arb.min_units",           1L))
  )
}

# --- ensure_M: rebuild matrices from state$latest (idempotent) ---------------
ensure_M <- function(state = .state) {
  stopifnot(is.environment(state), exists("latest", envir = state, inherits = FALSE))
  qm <- build_quote_map(as.list.environment(state$latest))
  if (!length(ls(qm))) stop("No quotes in state$latest", call. = FALSE)
  pm <- make_price_matrices(qm)
  stopifnot(is.matrix(pm$M), nrow(pm$M) > 0)
  state$qm   <- qm
  state$M    <- pm$M
  state$BID  <- pm$BID
  state$ASK  <- pm$ASK
  new_ccys   <- rownames(pm$M)
  if (is.null(state$ccys) || !identical(state$ccys, new_ccys)) {
    state$ccys <- new_ccys
    state$.idx <- NULL
  } else {
    state$ccys <- new_ccys
  }
  return(state$M)
}

# ===== quotes (matrix-first) ==================================================
q_bid <- function(pair, state = .state) {
  x <- state$latest[[pair]]; if (is.null(x)) return(NA_real_); as.numeric(x$bid)
}
q_ask <- function(pair, state = .state) {
  x <- state$latest[[pair]]; if (is.null(x)) return(NA_real_); as.numeric(x$ask)
}
q_mid <- function(pair, state = .state) {
  b <- q_bid(pair, state); a <- q_ask(pair, state)
  if (!is.finite(b) || !is.finite(a)) return(NA_real_)
  0.5*(a + b)
}

.ensure_idx_cache <- function(state = .state) {
  if (!is.null(state$.idx)) return(invisible(state$.idx))
  ccys <- state$ccys %||% rownames(state$BID)
  stopifnot(is.character(ccys), length(ccys) > 0)
  idx <- seq_along(ccys); names(idx) <- ccys
  state$.idx <- idx
  invisible(idx)
}

.ij <- function(a, b, state = .state) {
  idx <- .ensure_idx_cache(state) %||% state$.idx
  i <- idx[[a]]; j <- idx[[b]]
  if (is.null(i) || is.null(j)) return(c(NA_integer_, NA_integer_))
  c(as.integer(i), as.integer(j))
}

q_bid2 <- function(a, b, state = .state) {
  if (!is.null(state$BID)) {
    ij <- .ij(a, b, state); if (any(is.na(ij))) return(NA_real_)
    v <- state$BID[ij[1], ij[2]]; if (is.finite(v)) return(v)
  }
  q_bid(paste0(a,"/",b), state)
}

q_ask2 <- function(a, b, state = .state) {
  if (!is.null(state$ASK)) {
    ij <- .ij(a, b, state); if (any(is.na(ij))) return(NA_real_)
    v <- state$ASK[ij[1], ij[2]]; if (is.finite(v)) return(v)
  }
  q_ask(paste0(a,"/",b), state)
}

# ===== dynamic slippage (vol) =================================================
.vol_env <- new.env(parent = emptyenv())

push_mid <- function(pair, mid, max_n = getOption("arb.vol.buf_len", 120L)) {
  if (!is.finite(mid)) return(invisible())
  rb <- .vol_env[[pair]]
  if (is.null(rb)) rb <- list(buf = numeric(max_n), idx = 0L, n = 0L)
  if (length(rb$buf) != max_n) rb$buf <- numeric(max_n)
  idx <- (rb$idx %% max_n) + 1L
  rb$buf[idx] <- mid
  rb$idx <- idx
  rb$n <- min(rb$n + 1L, max_n)
  .vol_env[[pair]] <- rb
}

vol_bps <- function(pair, window = getOption("arb.vol.window", 60L)) {
  rb <- .vol_env[[pair]]; if (is.null(rb) || rb$n < 3L) return(NA_real_)
  n <- min(window, rb$n)
  out <- numeric(n)
  for (k in 1:n) {
    pos <- ((rb$idx - (n - k)) - 1L) %% length(rb$buf) + 1L
    out[k] <- rb$buf[pos]
  }
  sd(diff(log(out)), na.rm = TRUE) * 1e4
}

# Aksepterer ... slik at gamle kall med state=state ikke feiler
route_vol_bps <- function(pairs, ...) {
  vals <- vapply(pairs, vol_bps, numeric(1))
  vals <- vals[is.finite(vals)]
  if (!length(vals)) return(NA_real_)
  max(vals)
}

# ===== spread caps + gating ===================================================
.init_cap_matrix <- function(state = .state) {
  if (!is.null(state$CAP)) return(invisible(state$CAP))
  ccys <- state$ccys %||% rownames(state$BID)
  .ensure_idx_cache(state)
  n <- length(ccys)
  CAP <- matrix(getOption("arb.spread_default_cap_bps", 20.0),
                n, n, dimnames = list(ccys, ccys))
  spread_caps <- getOption("arb.spread_cap")
  for (a in ccys) for (b in ccys) {
    if (a == b) next
    cap_from <- tryCatch(spread_caps[[a]], error = function(e) NA_real_)
    cap_to   <- tryCatch(spread_caps[[b]], error = function(e) NA_real_)
    cap <- suppressWarnings(max(c(cap_from, cap_to), na.rm = TRUE))
    if (is.finite(cap)) CAP[a, b] <- as.numeric(cap)
  }
  state$CAP <- CAP
  invisible(CAP)
}

max_spread_for2 <- function(a, b, state = .state) {
  .init_cap_matrix(state)
  ij <- .ij(a, b, state); if (any(is.na(ij))) return(Inf)
  state$CAP[ij[1], ij[2]]
}

pair_spread_bps2 <- function(a, b, state = .state) {
  bq <- q_bid2(a, b, state); aq <- q_ask2(a, b, state)
  if (!is.finite(bq) || !is.finite(aq) || bq <= 0 || aq <= 0) return(Inf)
  m   <- 0.5 * (aq + bq)
  bps <- (aq - bq) / m * 1e4
  cap <- max_spread_for2(a, b, state)
  if (bps > cap) Inf else bps
}

# ===== liquidity (lightweight gates) =========================================
has_liquidity <- function(from_ccy, to_ccy,
                          min_notional_from = getOption("arb.liq.min_notional", 20),
                          state = .state,
                          depth_levels = getOption("arb.liq.depth_levels", 3L),
                          ttl_ms = getOption("arb.liq.cache_ttl_ms", 300L)) {
  # Vi m√• st√∏tte at Oanda ikke tilbyr alle kryss i "direkte" retning.
  # Pr√∏v b√•de FROM_TO og TO_FROM og aksepter likviditet hvis √©n av de finnes.
  direct  <- paste0(from_ccy, "_", to_ccy)
  inverse <- paste0(to_ccy, "_", from_ccy)
  
  now_ms <- as.numeric(Sys.time()) * 1000
  
  # cache-hit (direkte)
  oc <- state$ob_cache[[direct]]
  if (!is.null(oc) && (now_ms - oc$ts) < ttl_ms) {
    if (isTRUE(oc$ok)) return(TRUE)
    # hvis direkte var FALSE, pr√∏v inverse-cache f√∏r vi g√•r til API
    oc2 <- state$ob_cache[[inverse]]
    if (!is.null(oc2) && (now_ms - oc2$ts) < ttl_ms) return(isTRUE(oc2$ok))
  }
  
  orderbook_ok <- function(ob) {
    if (inherits(ob, "try-error") || is.null(ob)) return(FALSE)
    if (!is.null(ob$price) && length(ob$price)) return(TRUE)
    if (!is.null(ob$orderBook)) {
      if (!is.null(ob$orderBook$price) && length(ob$orderBook$price)) return(TRUE)
      if (!is.null(ob$orderBook$buckets) && NROW(ob$orderBook$buckets)) return(TRUE)
    }
    FALSE
  }
  
  ok_direct <- FALSE
  ok_inverse <- FALSE
  
  # pr√∏v direkte
  ob1 <- try(state$DS$orderbook(direct), silent = TRUE)
  ok_direct <- orderbook_ok(ob1)
  state$ob_cache[[direct]] <- list(ts = now_ms, ok = ok_direct)
  
  if (!ok_direct) {
    # pr√∏v inverse
    ob2 <- try(state$DS$orderbook(inverse), silent = TRUE)
    ok_inverse <- orderbook_ok(ob2)
    state$ob_cache[[inverse]] <- list(ts = now_ms, ok = ok_inverse)
  }
  
  isTRUE(ok_direct || ok_inverse)
}

# ===== choose instrument/side + units ========================================
pick_leg <- function(a, b, state = .state) {
  # Meglerens symbols (kan feile ‚Äì da faller vi tilbake til gammel logikk)
  syms <- try(state$DS$list_symbols(), silent = TRUE)
  listed <- if (!inherits(syms, "try-error")) as.character(syms) else NULL
  
  ab  <- paste0(a,"_",b)
  ba  <- paste0(b,"_",a)
  bq1 <- q_bid2(a,b,state); aq1 <- q_ask2(a,b,state)
  bq2 <- q_bid2(b,a,state); aq2 <- q_ask2(b,a,state)
  
  # 1) Foretrekk retningen som faktisk er LISTET hos megler + har quotes
  if (!is.null(listed) && (ab %in% listed) && is.finite(bq1) && is.finite(aq1))
    return(list(instrument = ab, side = "sell", price = bq1, pair = paste0(a,"/",b)))
  if (!is.null(listed) && (ba %in% listed) && is.finite(bq2) && is.finite(aq2))
    return(list(instrument = ba, side = "buy",  price = aq2, pair = paste0(b,"/",a)))
  
  # 2) Fallback: gammel logikk hvis vi mangler listing
  if (is.finite(bq1) && is.finite(aq1))
    return(list(instrument = ab, side = "sell", price = bq1, pair = paste0(a,"/",b)))
  if (is.finite(bq2) && is.finite(aq2))
    return(list(instrument = ba, side = "buy",  price = aq2, pair = paste0(b,"/",a)))
  
  NULL
}

amount_to_units <- function(amount_in_A, from_ccy, to_ccy, state = .state) {
  cfg <- TRD_CFG()
  leg <- pick_leg(from_ccy, to_ccy, state); if (is.null(leg)) return(NULL)
  if (leg$side == "sell") {
    units_base <- amount_in_A
    units <- max(cfg$min_units, floor(units_base))
    recv_B <- units * leg$price
    list(instrument = leg$instrument, side = "sell", units = as.integer(units),
         recv_amount = recv_B, recv_ccy = to_ccy, pair = leg$pair)
  } else {
    units_base <- amount_in_A / leg$price
    units <- max(cfg$min_units, floor(units_base))
    if (units <= 0) return(NULL)
    recv_B <- units
    list(instrument = leg$instrument, side = "buy", units = as.integer(units),
         recv_amount = recv_B, recv_ccy = to_ccy, pair = leg$pair)
  }
}

# Sjekk at instrument faktisk finnes/listes av megler
instrument_available <- function(instr, state = .state) {
  syms <- try(state$DS$list_symbols(), silent = TRUE)
  if (inherits(syms, "try-error")) return(TRUE)  # hvis DS ikke st√∏tter listing, ikke blokker
  instr %in% syms
}

# ===== order plumbing =========================================================
.trd_inflight <- FALSE
.trd_last_ts  <- as.numeric(Sys.time()) - 999

.place_leg <- function(instrument, side, units, state = .state) {
  units <- as.integer(units)
  if (!is.finite(units) || units <= 0) {
    return(list(ok = FALSE, err = "invalid_units"))
  }
  err <- NULL; ok <- TRUE
  tryCatch(
    { state$DS$place_market(instrument = instrument, side = side, units = units) },
    error = function(e) { ok <<- FALSE; err <<- conditionMessage(e) }
  )
  list(ok = isTRUE(ok), err = err)
}

.opposite_side <- function(side) if (identical(side, "buy")) "sell" else "buy"

# ===== main execution for one triangle =======================================
execute_triangle <- function(route_vec, notional_S,
                             state = .state,
                             dry_run = NULL) {
  cfg    <- TRD_CFG()
  logger <- getOption("arb.core_logger", function(...) invisible(NULL))
  if (is.null(dry_run)) dry_run <- cfg$dry_run
  
  stopifnot(length(route_vec) == 4, route_vec[1] == route_vec[4])
  S <- route_vec[1]; X <- route_vec[2]; Y <- route_vec[3]
  
  now <- as.numeric(Sys.time())
  if (.trd_inflight || (now - .trd_last_ts) < cfg$cooldown_sec) {
    logger("trade_skip", list(reason = "inflight/cooldown", route = route_vec,
                              cooldown_sec = cfg$cooldown_sec))
    return(FALSE)
  }
  assign(".trd_inflight", TRUE, envir = .GlobalEnv)
  on.exit(assign(".trd_inflight", FALSE, envir = .GlobalEnv), add = TRUE)
  
  # spread gates
  sp1 <- pair_spread_bps2(S, X, state); if (!is.finite(sp1)) { logger("trade_skip", list(reason="spread", leg="S->X", route=route_vec)); return(FALSE) }
  sp2 <- pair_spread_bps2(X, Y, state); if (!is.finite(sp2)) { logger("trade_skip", list(reason="spread", leg="X->Y", route=route_vec)); return(FALSE) }
  sp3 <- pair_spread_bps2(Y, S, state); if (!is.finite(sp3)) { logger("trade_skip", list(reason="spread", leg="Y->S", route=route_vec)); return(FALSE) }
  
  # liquidity + sizing to orders
  if (!has_liquidity(S, X, notional_S, state)) { logger("trade_skip", list(reason="liquidity", leg="S->X", route=route_vec)); return(FALSE) }
  s1 <- amount_to_units(notional_S, S, X, state); if (is.null(s1) || s1$units < cfg$min_units) { logger("trade_skip", list(reason="leg1_units", route=route_vec)); return(FALSE) }
  
  if (!has_liquidity(X, Y, s1$recv_amount, state)) { logger("trade_skip", list(reason="liquidity", leg="X->Y", route=route_vec)); return(FALSE) }
  s2 <- amount_to_units(s1$recv_amount, X, Y, state); if (is.null(s2) || s2$units < cfg$min_units) { logger("trade_skip", list(reason="leg2_units", route=route_vec)); return(FALSE) }
  
  if (!has_liquidity(Y, S, s2$recv_amount, state)) { logger("trade_skip", list(reason="liquidity", leg="Y->S", route=route_vec)); return(FALSE) }
  s3 <- amount_to_units(s2$recv_amount, Y, S, state); if (is.null(s3) || s3$units < cfg$min_units) { logger("trade_skip", list(reason="leg3_units", route=route_vec)); return(FALSE) }
  
  # Sjekk at instrumentene faktisk er listet/handlbare
  if (!instrument_available(s1$instrument, state)) { logger("trade_skip", list(reason="instrument_unavailable", leg="S->X", instrument=s1$instrument, route=route_vec)); return(FALSE) }
  if (!instrument_available(s2$instrument, state)) { logger("trade_skip", list(reason="instrument_unavailable", leg="X->Y", instrument=s2$instrument, route=route_vec)); return(FALSE) }
  if (!instrument_available(s3$instrument, state)) { logger("trade_skip", list(reason="instrument_unavailable", leg="Y->S", instrument=s3$instrument, route=route_vec)); return(FALSE) }
  
  # Logg plan f√∏r vi sender
  logger("trade_plan", list(
    route = route_vec,
    legs  = list(
      list(leg="1", side = s1$side, units = s1$units, instrument = s1$instrument),
      list(leg="2", side = s2$side, units = s2$units, instrument = s2$instrument),
      list(leg="3", side = s3$side, units = s3$units, instrument = s3$instrument)
    )
  ))
  
  if (isTRUE(dry_run)) {
    logger("trade_dryrun", list(
      route = route_vec,
      legs  = list(
        list(side = s1$side, units = s1$units, instrument = s1$instrument),
        list(side = s2$side, units = s2$units, instrument = s2$instrument),
        list(side = s3$side, units = s3$units, instrument = s3$instrument)
      )
    ))
    return(TRUE)
  }
  
  # Send legg for legg ‚Äì logg broker-feil ved miss
  step1 <- .place_leg(s1$instrument, s1$side, s1$units, state)
  if (!step1$ok) { logger("trade_fail", list(stage = "leg1_send", route = route_vec, error = step1$err)); return(FALSE) }
  
  step2 <- .place_leg(s2$instrument, s2$side, s2$units, state)
  if (!step2$ok) {
    .place_leg(s1$instrument, .opposite_side(s1$side), s1$units, state)
    logger("trade_fail", list(stage = "leg2_send_rollback_leg1", route = route_vec, error = step2$err))
    return(FALSE)
  }
  
  step3 <- .place_leg(s3$instrument, s3$side, s3$units, state)
  if (!step3$ok) {
    .place_leg(s2$instrument, .opposite_side(s2$side), s2$units, state)
    .place_leg(s1$instrument, .opposite_side(s1$side), s1$units, state)
    logger("trade_fail", list(stage = "leg3_send_rollback_1_2", route = route_vec, error = step3$err))
    return(FALSE)
  }
  
  assign(".trd_last_ts", now, envir = .GlobalEnv)
  logger("trade", list(result = "filled", route = route_vec,
                       legs = list(
                         list(side = s1$side, units = s1$units, instrument = s1$instrument),
                         list(side = s2$side, units = s2$units, instrument = s2$instrument),
                         list(side = s3$side, units = s3$units, instrument = s3$instrument)
                       )))
  TRUE
}

# ===== Kelly sizing ===========================================================
kelly_size <- function(edge_net_bps, vol_bps_route, bankroll, frac = NULL, cap = NULL) {
  cfg <- TRD_CFG()
  if (is.null(frac)) frac <- cfg$frac_kelly
  if (is.null(cap))  cap  <- cfg$max_notional
  
  # NYTT: bruk fallback-vol ved ikke-positiv vol
  if (!is.finite(vol_bps_route) || vol_bps_route <= 0) {
    vol_bps_route <- getOption("arb.kelly_vol_fallback_bps", getOption("arb.rvbps_fallback_bps", 10.0))
  }
  
  if (!is.finite(edge_net_bps)) return(max(cfg$min_units, 0))  # trygt minimum
  
  bps_scale <- getOption("arb.bps_scale", 1e4)
  var_floor <- getOption("arb.kelly_var_floor", 1e-12)
  mu  <- edge_net_bps / bps_scale
  var <- max((vol_bps_route / bps_scale)^2, var_floor)
  f   <- max(0, min(1, mu / var)) * frac
  size <- bankroll * f
  max(cfg$min_units, min(size, cap))
}

# ===== MAIN (engine-first) ====================================================
maybe_trade_best_triangle <- function(state = .state,
                                      start_currency,
                                      bankroll) {
  logger <- getOption("arb.core_logger", function(...) invisible(NULL))
  cfg    <- TRD_CFG()
  
  stopifnot(is.matrix(state$M), nrow(state$M) > 0)
  if (missing(start_currency)) start_currency <- rownames(state$M)[1]
  if (missing(bankroll))        bankroll <- getOption("arb.bankroll_default", 10000)
  
  # 0) warm vol buffer
  if (length(state$latest)) for (p in names(state$latest)) push_mid(p, q_mid(p, state))
  
  # 1) ensure M/BID/ASK
  M <- ensure_M(state)
  .ensure_idx_cache(state); .init_cap_matrix(state)
  
  # 2) engine reinit/refresh/mark-changes
  engine_reinit_if_needed(state, start_currency)
  engine_refresh_mats(state)
  engine_mark_m_changes(prevM = state$M_prev, newM = state$M)
  state$M_prev <- state$M
  
  # 3) evaluer top-K fra engine
  res <- engine_eval_topK(
    K = getOption("arb.topK.print", 25L),
    fee_pct = getOption("arb.fee_pct", 0),
    slip_base_frac = (getOption("arb.assumed_slip_bps", 0))/1e4,
    buf_base_frac  = (getOption("arb.safety_buffer_bps", 0))/1e4,
    k_slip = getOption("arb.k_slip", 0.30),
    rvbps_fallback_bps = getOption("arb.rvbps_fallback_bps", 10.0),
    start_qty_base = bankroll
  )
  
  if (is.null(res) || !length(res$idx)) {
    logger("trade_skip", list(
      reason    = "no_candidates_from_engine",
      start_ccy = start_currency,
      bankroll  = bankroll
    ))
    return(invisible(FALSE))
  }
  
  traded <- FALSE
  now_ts <- as.numeric(Sys.time())
  since_last_base <- now_ts - .trd_last_ts
  
  # 4) loop kandidater
  N <- length(res$idx)
  for (i in seq_len(N)) {
    mid <- state$ccys[ res$mid_i[i] ]
    end <- state$ccys[ res$end_i[i] ]
    route_vec <- c(start_currency, mid, end, start_currency)
    
    # dyn edge / threshold
    fee_pct_opt           <- getOption("arb.fee_pct", 0)
    assumed_slip_bps_opt  <- getOption("arb.assumed_slip_bps", 0)
    safety_buffer_bps_opt <- getOption("arb.safety_buffer_bps", 0)
    slip_base_frac <- (assumed_slip_bps_opt %||% 0)/1e4
    buf_base_frac  <- (safety_buffer_bps_opt %||% 0)/1e4
    
    pairs <- c(paste0(route_vec[1],"/",route_vec[2]),
               paste0(route_vec[2],"/",route_vec[3]),
               paste0(route_vec[3],"/",route_vec[1]))
    rvbps <- route_vol_bps(pairs)
    k_slip <- getOption("arb.k_slip", 0.30)
    slip_dyn_frac <- slip_base_frac + if (is.finite(rvbps)) k_slip * (rvbps/1e4) else 0
    thr_dyn_frac  <- edge_trigger_threshold(fee_pct_opt, slip_dyn_frac, buf_base_frac)
    
    # edge i motor er (prod/dir - 1); bruk edge - threshold
    dyn_edge_bps <- 1e4 * ((res$edge[i] %||% NA_real_) - thr_dyn_frac)
    if (!is.finite(dyn_edge_bps) || dyn_edge_bps < cfg$min_edge_bps) next
    
    # quick gates
    if (!is.finite(pair_spread_bps2(start_currency, mid, state))) next
    if (!is.finite(pair_spread_bps2(mid,           end, state)))  next
    if (!is.finite(pair_spread_bps2(end, start_currency, state))) next
    
    if (!has_liquidity(start_currency, mid,  state = state)) next
    if (!has_liquidity(mid,           end,  state = state)) next
    if (!has_liquidity(end,           start_currency, state = state)) next
    
    # sizing (Kelly)
    rvbps_eff <- if (is.finite(rvbps)) rvbps else getOption("arb.rvbps_fallback_bps", 10.0)
    size_S <- kelly_size(edge_net_bps = dyn_edge_bps, vol_bps_route = rvbps_eff, bankroll = bankroll)
    
    # sanity-PnL
    ok_trade <- FALSE
    t0 <- proc.time()[3]; res_pnl <- NULL
    tryCatch({ res_pnl <- tri_arbitrage_pnl(start_currency, mid, end, state = state) },
             error = function(e) res_pnl <<- list(ok = FALSE, err = conditionMessage(e)))
    dt <- proc.time()[3] - t0
    
    if (is.list(res_pnl) && isTRUE(res_pnl$ok) && is.finite(res_pnl$pnl_after_costs) && res_pnl$pnl_after_costs > 0) {
      t1 <- proc.time()[3]; err2 <- NULL
      tryCatch({ ok_trade <- execute_triangle(route_vec, size_S, state = state) },
               error = function(e) { err2 <<- conditionMessage(e); ok_trade <<- FALSE })
      dt2 <- proc.time()[3] - t1
      if (ok_trade) {
        logger("trade", list(
          result       = "attempt_ok",
          route        = route_vec,
          dyn_edge_bps = dyn_edge_bps,
          vol_bps      = rvbps_eff,
          size_start   = size_S,
          start_ccy    = route_vec[1],
          time_eval_s  = dt,
          time_exec_s  = dt2,
          dry_run      = TRD_CFG()$dry_run
        ))
        traded <- TRUE
        break
      } else {
        logger("trade_fail", list(
          result       = "order_send_fail",
          error        = err2 %||% "unknown",
          route        = route_vec,
          dyn_edge_bps = dyn_edge_bps,
          size_start   = size_S,
          start_ccy    = route_vec[1],
          time_eval_s  = dt,
          dry_run      = TRD_CFG()$dry_run
        ))
      }
    } else {
      logger("trade_skip", list(
        reason        = "sanity/cooldown/liquidity/order",
        route         = route_vec,
        dyn_edge_bps  = dyn_edge_bps,
        vol_bps       = rvbps_eff,
        size_start    = size_S,
        inflight      = .trd_inflight,
        since_last_s  = since_last_base,
        time_eval_s   = dt,
        dry_run       = TRD_CFG()$dry_run
      ))
    }
  }
  
  invisible(traded)
}



################################
###   üß© C++ / PY / TXT CODE   ###
################################


==========================================================
üìÑ ALL_CODE copy.txt
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/ALL_CODE copy.txt
==========================================================
for f in engine.c engine.h routes.c routes.h matrix.c matrix.h ringbuffer.h results.h ticks.c ticks.h engine_R.c engine_py.py CMakeLists.txt; do
  echo "===== $f ====="
  sed -n '1,99999p' "$f"
  echo
done > ALL_CODE.txt



cd ~/user/sigurdberner/"FX_ARBITRAGE_FINALE copy"

cat ALL_CODE.txt | pbcopy


==========================================================
üìÑ ALL_CODE.txt
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/ALL_CODE.txt
==========================================================

========================================
FILE: ALL_CODE copy.txt
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/ALL_CODE copy.txt
========================================
for f in engine.c engine.h routes.c routes.h matrix.c matrix.h ringbuffer.h results.h ticks.c ticks.h engine_R.c engine_py.py CMakeLists.txt; do
  echo "===== $f ====="
  sed -n '1,99999p' "$f"
  echo
done > ALL_CODE.txt



cd ~/user/sigurdberner/"FX_ARBITRAGE_FINALE copy"

cat ALL_CODE.txt | pbcopy


========================================
FILE: CMakeLists.txt
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/CMakeLists.txt
========================================
cmake_minimum_required(VERSION 3.16)
project(engine_v4 C)

set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

# macOS: allow unresolved symbols for R
if(APPLE)
    set(CMAKE_C_VISIBILITY_PRESET default)
    set(CMAKE_VISIBILITY_INLINES_HIDDEN OFF)
endif()

# ---- Finn R include path ----
execute_process(
  COMMAND R RHOME
  OUTPUT_VARIABLE R_HOME
  OUTPUT_STRIP_TRAILING_WHITESPACE
)

set(R_INCLUDE_DIR "${R_HOME}/include")

# ---- Kilder ----
set(SRC
    engine.c
    engine_R.c
    routes.c
    matrix.c
    ticks.c
)

add_library(engine_v4 SHARED ${SRC})

# ---- Include dirs ----
target_include_directories(engine_v4 PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${R_INCLUDE_DIR}
)

# ---- macOS: dynamic lookup ----
if(APPLE)
    target_link_options(engine_v4 PRIVATE "-Wl,-undefined,dynamic_lookup")
endif()

# ---- Optimalisering ----
if (CMAKE_C_COMPILER_ID MATCHES "Clang|AppleClang|GNU")
    target_compile_options(engine_v4 PRIVATE -O3 -march=native)
endif()

set_target_properties(engine_v4 PROPERTIES OUTPUT_NAME "engine_v4")


========================================
FILE: engine wrappers usikker 2.r
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/engine wrappers usikker 2.r
========================================
    # ================================================================
#  Engine_Wrapper.R ‚Äî R KOBLING TIL engine_v4 (TRI only)
# ================================================================

`%||%` <- function(a, b) if (is.null(a)) b else a

.eng <- NULL
.eng_meta <- list(ccys = NULL, start_ccy = NULL)

# -----------------------------------------------------------
# 1) Last C-motor (dylib)
# -----------------------------------------------------------
engine_load <- function(path = file.path("C++", "build", "libengine_v4.dylib")) {
  path <- normalizePath(path, mustWork = TRUE)
  if (!is.loaded("engine_create")) {
    dyn.load(path)
  }
  invisible(TRUE)
}

# -----------------------------------------------------------
# 2) Generate TRI route matrix (mid, end)
#    ‚úî matches C signature EXACTLY
# -----------------------------------------------------------
precompute_route_idx <- function(ccys, start_ccy) {
  stopifnot(is.character(ccys), length(ccys) > 2L)
  
  s <- match(start_ccy, ccys)
  if (is.na(s))
    stop("precompute_route_idx: start_ccy not in ccys")
  
  idx <- setdiff(seq_along(ccys), s)
  g <- expand.grid(mid_i = idx, end_i = idx, KEEP.OUT.ATTRS = FALSE)
  g <- g[g$mid_i != g$end_i, ]
  
  out <- as.matrix(
    data.frame(
      mid_i = as.integer(g$mid_i),
      end_i = as.integer(g$end_i)
    )
  )
  storage.mode(out) <- "integer"
  out
}

.engine_push_mats <- function(ptr, state) {
  M   <- state$M
  BID <- state$BID
  ASK <- state$ASK
  
  n <- nrow(M)
  
  for (i in seq_len(n)) {
    for (j in seq_len(n)) {
      b <- BID[i, j]
      a <- ASK[i, j]
      
      if (is.finite(b) && is.finite(a) && b > 0 && a > 0) {
        .Call("engine_push_tick_R",
              ptr,
              as.integer(i),
              as.integer(j),
              as.numeric(b),
              as.numeric(a))
      }
    }
  }
  
  invisible(TRUE)
}




engine_push_tick <- function(ptr, i, j, bid, ask) {
  .Call(
    "engine_push_tick_R",
    ptr,
    as.integer(i),
    as.integer(j),
    as.numeric(bid),
    as.numeric(ask)
  )
}
# -----------------------------------------------------------
# 3) Pump full matrix into engine
# -----------------------------------------------------------


# -----------------------------------------------------------
# 4) Init full engine (TRI only)
# -----------------------------------------------------------
engine_init <- function(state, start_ccy) {
  stopifnot(
    is.matrix(state$M),
    is.matrix(state$BID),
    is.matrix(state$ASK)
  )
  
  ccys <- rownames(state$M)
  start_i <- match(start_ccy, ccys)
  if (is.na(start_i))
    stop("engine_init: start_ccy not in M")
  
  # Build routes exactly as C expects (mid, end)
  if (is.null(state$route_idx) || !nrow(state$route_idx)) {
    state$route_idx <- precompute_route_idx(ccys, start_ccy)
  }
  
  if (!nrow(state$route_idx))
    stop("engine_init: route_idx empty")
  
  # ---------- C CALL ----------
  eng <- .Call(
    "engine_create",
    state$route_idx,           # integer matrix (n x 2)
    as.integer(start_i),       # start index (1-based)
    as.integer(length(ccys))   # n_ccy
  )
  # -----------------------------
  
  # Start C-thread
  .Call("engine_start_R", eng)
  
  # Push initial matrix state
  .engine_push_mats(eng, state)
  
  # Save static pointer
  .eng <<- eng
  .eng_meta <<- list(
    ccys = ccys,
    start_ccy = start_ccy
  )
  
  invisible(TRUE)
}

# -----------------------------------------------------------
# 5) Refresh engine matrix (on rebuild)
# -----------------------------------------------------------
engine_refresh_mats <- function(state) {
  if (is.null(.eng)) return(invisible(FALSE))
  .engine_push_mats(.eng, state)
  invisible(TRUE)
}

engine_reinit_if_needed <- function(state, start_ccy) {
  ccys <- rownames(state$M)
  
  need <- (
    is.null(.eng) ||
      !identical(.eng_meta$ccys, ccys) ||
      !identical(.eng_meta$start_ccy, start_ccy)
  )
  
  if (need)
    engine_init(state, start_ccy)
  
  invisible(TRUE)
}

# -----------------------------------------------------------
# 6) Poll ‚Üí data.frame
# -----------------------------------------------------------
engine_poll_df <- function() {
  if (is.null(.eng)) return(NULL)
  
  df <- .Call("engine_poll", .eng)
  if (is.null(df) || nrow(df) == 0)
    return(NULL)
  
  df
}

# -----------------------------------------------------------
# 7) Tick eval (just poll)
# -----------------------------------------------------------
engine_tick_eval <- function(state) {
  if (is.null(.eng)) return(NULL)
  engine_poll_df()
}

engine_wrappers_ready <- function() TRUE




engine_push_tick <- function(ptr, i, j, bid, ask) {
  .Call(
    "engine_push_tick_R",
    ptr,
    as.integer(i),
    as.integer(j),
    as.numeric(bid),
    as.numeric(ask)
  )
}












========================================
FILE: engine_py.py
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/engine_py.py
========================================
import ctypes
import os
import sys

# Adjust name if you build different
if sys.platform == "darwin":
    LIBNAME = "libengine_v4.dylib"
elif sys.platform.startswith("linux"):
    LIBNAME = "libengine_v4.so"
else:
    raise RuntimeError("Unsupported platform")

_here = os.path.dirname(os.path.abspath(__file__))
_libpath = os.path.join(_here, LIBNAME)

lib = ctypes.CDLL(_libpath)

# ---- signatures ----
lib.engine_create_tri.restype = ctypes.c_void_p
lib.engine_create_tri.argtypes = [
    ctypes.c_int, ctypes.c_int,
    ctypes.POINTER(ctypes.c_int), ctypes.c_int,
    ctypes.c_int
]

lib.engine_start.restype = ctypes.c_int
lib.engine_start.argtypes = [ctypes.c_void_p]

lib.engine_stop.restype = None
lib.engine_stop.argtypes = [ctypes.c_void_p]

lib.engine_destroy.restype = None
lib.engine_destroy.argtypes = [ctypes.c_void_p]

lib.engine_push_tick.restype = ctypes.c_int
lib.engine_push_tick.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_int, ctypes.c_double, ctypes.c_double]

class Result(ctypes.Structure):
    _fields_ = [
        ("route_id", ctypes.c_int),
        ("mid_i", ctypes.c_int),
        ("end_i", ctypes.c_int),
        ("edge", ctypes.c_double),
        ("final_base", ctypes.c_double),
        ("pnl", ctypes.c_double),
        ("pct", ctypes.c_double),
        ("ts_ns", ctypes.c_uint64),
    ]

lib.engine_pop_result.restype = ctypes.c_int
lib.engine_pop_result.argtypes = [ctypes.c_void_p, ctypes.POINTER(Result)]

class Engine:
    def __init__(self, n_ccy, start_i_1b, routes_mid_end_1b):
        # routes_mid_end_1b: list of (mid,end) 1-based
        flat = []
        for mid, end in routes_mid_end_1b:
            flat.extend([mid, end])
        arr = (ctypes.c_int * len(flat))(*flat)
        self._eng = lib.engine_create_tri(n_ccy, start_i_1b, arr, len(routes_mid_end_1b), 1)
        if not self._eng:
            raise RuntimeError("engine_create_tri failed")

    def start(self):
        return bool(lib.engine_start(self._eng))

    def stop(self):
        lib.engine_stop(self._eng)

    def destroy(self):
        if self._eng:
            lib.engine_destroy(self._eng)
            self._eng = None

    def push_tick(self, i_1b, j_1b, bid, ask):
        return bool(lib.engine_push_tick(self._eng, i_1b, j_1b, float(bid), float(ask)))

    def poll(self):
        out = []
        r = Result()
        while lib.engine_pop_result(self._eng, ctypes.byref(r)):
            out.append({
                "route_id": r.route_id,
                "mid": r.mid_i,
                "end": r.end_i,
                "pnl": r.pnl,
                "edge": r.edge,
                "final_base": r.final_base,
                "pct": r.pct,
                "ts_ns": int(r.ts_ns),
            })
        return out


========================================
FILE: engine_R.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/engine_R.c
========================================
#include <R.h>
#include <Rinternals.h>
#include <stdint.h>
#include <stdlib.h>

#include "engine.h"
#include "results.h"

// finalizer
static void engine_xptr_finalizer(SEXP xptr)
{
    engine_t *eng = (engine_t *)R_ExternalPtrAddr(xptr);
    if (eng)
    {
        engine_stop(eng);
        engine_destroy(eng);
        R_ClearExternalPtr(xptr);
    }
}

// R integer matrix is column-major; convert to row-major int*
static int *int_matrix_to_rowmajor(SEXP mat, int *out_nrow, int *out_ncol)
{
    if (!isInteger(mat) || !isMatrix(mat))
        error("routes must be an integer matrix");

    SEXP dim = getAttrib(mat, R_DimSymbol);
    int nrow = INTEGER(dim)[0];
    int ncol = INTEGER(dim)[1];
    if (nrow <= 0 || ncol <= 0)
        error("routes has invalid dimensions");

    int *src = INTEGER(mat);
    int *dst = (int *)malloc((size_t)nrow * (size_t)ncol * sizeof(int));
    if (!dst)
        error("malloc failed");

    for (int r = 0; r < nrow; ++r)
    {
        for (int c = 0; c < ncol; ++c)
        {
            dst[(size_t)r * (size_t)ncol + (size_t)c] = src[r + nrow * c];
        }
    }

    *out_nrow = nrow;
    *out_ncol = ncol;
    return dst;
}

// .Call engine_create(routes, start_i_1b, n_ccy)
// routes:
//   - if ncol==2 => TRI routes (mid,end) 1-based
//   - if ncol>=3 => cycle nodes (N legs) 1-based
SEXP engine_create(SEXP routes, SEXP start_i_1b, SEXP n_ccy)
{
    if (!isInteger(start_i_1b) || LENGTH(start_i_1b) != 1)
        error("start_i_1b must be integer(1)");
    if (!isInteger(n_ccy) || LENGTH(n_ccy) != 1)
        error("n_ccy must be integer(1)");

    int start = INTEGER(start_i_1b)[0];
    int n = INTEGER(n_ccy)[0];

    int nrow = 0, ncol = 0;
    int *rowmajor = int_matrix_to_rowmajor(routes, &nrow, &ncol);

    engine_t *eng = NULL;
    if (ncol == 2)
    {
        eng = engine_create_tri(n, start, rowmajor, nrow, /*one_based=*/1);
    }
    else if (ncol >= 3)
    {
        eng = engine_create_cycle(n, start, rowmajor, nrow, ncol, /*one_based=*/1);
    }
    else
    {
        free(rowmajor);
        error("routes must have at least 2 columns");
    }

    free(rowmajor);
    if (!eng)
        error("engine_create failed");

    SEXP xptr = PROTECT(R_MakeExternalPtr((void *)eng, R_NilValue, R_NilValue));
    R_RegisterCFinalizerEx(xptr, engine_xptr_finalizer, 1);
    UNPROTECT(1);
    return xptr;
}

SEXP engine_start_R(SEXP xptr)
{
    engine_t *eng = (engine_t *)R_ExternalPtrAddr(xptr);
    if (!eng)
        error("engine ptr is null");
    return ScalarLogical(engine_start(eng) ? 1 : 0);
}

SEXP engine_stop_R(SEXP xptr)
{
    engine_t *eng = (engine_t *)R_ExternalPtrAddr(xptr);
    if (!eng)
        return R_NilValue;
    engine_stop(eng);
    return R_NilValue;
}

SEXP engine_push_tick_R(SEXP xptr, SEXP i_1b, SEXP j_1b, SEXP bid, SEXP ask)
{
    engine_t *eng = (engine_t *)R_ExternalPtrAddr(xptr);
    if (!eng)
        error("engine ptr is null");

    if (!isInteger(i_1b) || LENGTH(i_1b) != 1)
        error("i_1b must be integer(1)");
    if (!isInteger(j_1b) || LENGTH(j_1b) != 1)
        error("j_1b must be integer(1)");
    if (!isReal(bid) || LENGTH(bid) != 1)
        error("bid must be double(1)");
    if (!isReal(ask) || LENGTH(ask) != 1)
        error("ask must be double(1)");

    int i = INTEGER(i_1b)[0];
    int j = INTEGER(j_1b)[0];
    double b = REAL(bid)[0];
    double a = REAL(ask)[0];

    return ScalarLogical(engine_push_tick(eng, i, j, b, a) ? 1 : 0);
}

SEXP engine_poll(SEXP xptr)
{
    engine_t *eng = (engine_t *)R_ExternalPtrAddr(xptr);
    if (!eng)
        error("engine ptr is null");

    // dynamic accumulate
    size_t cap = 1024, n = 0;
    int *route_id = (int *)malloc(cap * sizeof(int));
    int *mid_i = (int *)malloc(cap * sizeof(int));
    int *end_i = (int *)malloc(cap * sizeof(int));
    double *pnl = (double *)malloc(cap * sizeof(double));
    double *edge = (double *)malloc(cap * sizeof(double));
    double *fin = (double *)malloc(cap * sizeof(double));
    double *pct = (double *)malloc(cap * sizeof(double));
    double *ts = (double *)malloc(cap * sizeof(double));

    if (!route_id || !mid_i || !end_i || !pnl || !edge || !fin || !pct || !ts)
    {
        free(route_id);
        free(mid_i);
        free(end_i);
        free(pnl);
        free(edge);
        free(fin);
        free(pct);
        free(ts);
        error("malloc failed");
    }

    result_t r;
    while (engine_pop_result(eng, &r))
    {
        if (n == cap)
        {
            cap *= 2;
            route_id = (int *)realloc(route_id, cap * sizeof(int));
            mid_i = (int *)realloc(mid_i, cap * sizeof(int));
            end_i = (int *)realloc(end_i, cap * sizeof(int));
            pnl = (double *)realloc(pnl, cap * sizeof(double));
            edge = (double *)realloc(edge, cap * sizeof(double));
            fin = (double *)realloc(fin, cap * sizeof(double));
            pct = (double *)realloc(pct, cap * sizeof(double));
            ts = (double *)realloc(ts, cap * sizeof(double));
            if (!route_id || !mid_i || !end_i || !pnl || !edge || !fin || !pct || !ts)
                error("realloc failed");
        }
        route_id[n] = r.route_id;
        mid_i[n] = r.mid_i;
        end_i[n] = r.end_i;
        pnl[n] = r.pnl;
        edge[n] = r.edge;
        fin[n] = r.final_base;
        pct[n] = r.pct;
        ts[n] = (double)r.ts_ns;
        n++;
    }

    SEXP Route = PROTECT(allocVector(INTSXP, (R_xlen_t)n));
    SEXP Mid = PROTECT(allocVector(INTSXP, (R_xlen_t)n));
    SEXP End = PROTECT(allocVector(INTSXP, (R_xlen_t)n));
    SEXP Pnl = PROTECT(allocVector(REALSXP, (R_xlen_t)n));
    SEXP Edge = PROTECT(allocVector(REALSXP, (R_xlen_t)n));
    SEXP Fin = PROTECT(allocVector(REALSXP, (R_xlen_t)n));
    SEXP Pct = PROTECT(allocVector(REALSXP, (R_xlen_t)n));
    SEXP Ts = PROTECT(allocVector(REALSXP, (R_xlen_t)n));

    for (size_t i = 0; i < n; ++i)
    {
        INTEGER(Route)
        [i] = route_id[i];
        INTEGER(Mid)
        [i] = mid_i[i];
        INTEGER(End)
        [i] = end_i[i];
        REAL(Pnl)
        [i] = pnl[i];
        REAL(Edge)
        [i] = edge[i];
        REAL(Fin)
        [i] = fin[i];
        REAL(Pct)
        [i] = pct[i];
        REAL(Ts)
        [i] = ts[i];
    }

    free(route_id);
    free(mid_i);
    free(end_i);
    free(pnl);
    free(edge);
    free(fin);
    free(pct);
    free(ts);

    SEXP df = PROTECT(allocVector(VECSXP, 8));
    SET_VECTOR_ELT(df, 0, Route);
    SET_VECTOR_ELT(df, 1, Mid);
    SET_VECTOR_ELT(df, 2, End);
    SET_VECTOR_ELT(df, 3, Pnl);
    SET_VECTOR_ELT(df, 4, Edge);
    SET_VECTOR_ELT(df, 5, Fin);
    SET_VECTOR_ELT(df, 6, Pct);
    SET_VECTOR_ELT(df, 7, Ts);

    SEXP names = PROTECT(allocVector(STRSXP, 8));
    SET_STRING_ELT(names, 0, mkChar("route_id"));
    SET_STRING_ELT(names, 1, mkChar("mid"));
    SET_STRING_ELT(names, 2, mkChar("end"));
    SET_STRING_ELT(names, 3, mkChar("pnl"));
    SET_STRING_ELT(names, 4, mkChar("edge"));
    SET_STRING_ELT(names, 5, mkChar("final_base"));
    SET_STRING_ELT(names, 6, mkChar("pct"));
    SET_STRING_ELT(names, 7, mkChar("ts_ns"));
    setAttrib(df, R_NamesSymbol, names);

    SEXP rownames = PROTECT(allocVector(INTSXP, 2));
    INTEGER(rownames)
    [0] = NA_INTEGER;
    INTEGER(rownames)
    [1] = (int)n;
    setAttrib(df, R_RowNamesSymbol, rownames);

    setAttrib(df, R_ClassSymbol, mkString("data.frame"));

    UNPROTECT(11);
    return df;
}
#include <R_ext/Rdynload.h>

static const R_CallMethodDef callMethods[] = {
    {"engine_create", (DL_FUNC)&engine_create, 3},
    {"engine_start_R", (DL_FUNC)&engine_start_R, 1},
    {"engine_stop_R", (DL_FUNC)&engine_stop_R, 1},
    {"engine_push_tick_R", (DL_FUNC)&engine_push_tick_R, 5},
    {"engine_poll", (DL_FUNC)&engine_poll, 1},
    {NULL, NULL, 0}};

void R_init_engine_v4(DllInfo *dll)
{
    R_registerRoutines(dll, NULL, callMethods, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}


========================================
FILE: engine.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/engine.c
========================================
#include "engine.h"
#include "matrix.h"
#include "ringbuffer.h"
#include "routes.h"

#include <pthread.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

// Fixed ring sizes (A: fixed lock-free ringbuffer)
RB_DEFINE(tick_rb_t, tick_t, 8192)
RB_DEFINE(result_rb_t, result_t, 8192)

struct engine_t
{
    int n_ccy;
    int start0; // 0-based

    matrix_t mat;
    routes_t routes;

    // Threading
    _Atomic int running;
    pthread_t thread;

    // Buffers
    tick_rb_t tick_rb;
    result_rb_t result_rb;

    // Telemetry
    uint64_t ticks_received;
    uint64_t ticks_dropped;
    uint64_t results_emitted;
    uint64_t results_dropped;

    // scratch (avoid malloc each eval)
    double start_qty;
};

// ---------- Engine core math ----------
// TRI semantics matches din gamle engine:
// qty_mid = start_qty / ASK[start, mid]
// qty_end = qty_mid / ASK[mid, end]
// final   = qty_end * BID[end, start]
static inline int tri_simulate(const matrix_t *mat, int start0, int mid0, int end0,
                               double start_qty,
                               double *final_base, double *edge_out, double *pnl_out)
{
    size_t idx1 = matrix_idx(mat, start0, mid0);
    size_t idx2 = matrix_idx(mat, mid0, end0);
    size_t idx3 = matrix_idx(mat, end0, start0);

    double ask1 = mat->ASK[idx1];
    if (!(ask1 > 0.0) || !isfinite(ask1))
        return 0;
    double qty_mid = start_qty / ask1;

    double ask2 = mat->ASK[idx2];
    if (!(ask2 > 0.0) || !isfinite(ask2))
        return 0;
    double qty_end = qty_mid / ask2;

    double bid3 = mat->BID[idx3];
    if (!(bid3 > 0.0) || !isfinite(bid3))
        return 0;

    double fin = qty_end * bid3;
    double pnl = fin - start_qty;
    double edge = (fin / start_qty) - 1.0;

    *final_base = fin;
    *pnl_out = pnl;
    *edge_out = edge;
    return isfinite(pnl) ? 1 : 0;
}

static void eval_all_routes(engine_t *e)
{
    const int R = e->routes.n_routes;
    const uint64_t ts = ticks_now_ns();

    if (e->routes.kind == ROUTES_KIND_TRI)
    {
        int k = 0;
        for (; k + 3 < R; k += 4)
        {
            for (int u = 0; u < 4; ++u)
            {
                int kk = k + u;
                int mid0 = e->routes.mid0[kk];
                int end0 = e->routes.end0[kk];

                double fin, edge, pnl;
                if (tri_simulate(&e->mat, e->start0, mid0, end0, e->start_qty, &fin, &edge, &pnl))
                {
                    result_t r;
                    r.route_id = kk + 1;
                    r.mid_i = mid0 + 1;
                    r.end_i = end0 + 1;
                    r.final_base = fin;
                    r.edge = edge;
                    r.pnl = pnl;
                    r.pct = (pnl / e->start_qty) * 100.0;
                    r.ts_ns = ts;
                    if (result_rb_t_push(&e->result_rb, &r))
                    {
                        e->results_emitted++;
                    }
                    else
                    {
                        e->results_dropped++;
                    }
                }
            }
        }
        for (; k < R; ++k)
        {
            int mid0 = e->routes.mid0[k];
            int end0 = e->routes.end0[k];

            double fin, edge, pnl;
            if (tri_simulate(&e->mat, e->start0, mid0, end0, e->start_qty, &fin, &edge, &pnl))
            {
                result_t r;
                r.route_id = k + 1;
                r.mid_i = mid0 + 1;
                r.end_i = end0 + 1;
                r.final_base = fin;
                r.edge = edge;
                r.pnl = pnl;
                r.pct = (pnl / e->start_qty) * 100.0;
                r.ts_ns = ts;
                if (result_rb_t_push(&e->result_rb, &r))
                {
                    e->results_emitted++;
                }
                else
                {
                    e->results_dropped++;
                }
            }
        }
        return;
    }

    if (e->routes.kind == ROUTES_KIND_CYCLE)
    {
        const int n_cols = e->routes.n_cols;
        const int n_legs = n_cols - 1;

        for (int route = 0; route < R; ++route)
        {
            const int *row = &e->routes.nodes0[(size_t)route * (size_t)n_cols];

            double qty = e->start_qty;
            int ok = 1;

            for (int leg = 0; leg < n_legs - 1; ++leg)
            {
                int a = row[leg];
                int b = row[leg + 1];
                double ask = e->mat.ASK[matrix_idx(&e->mat, a, b)];
                if (!(ask > 0.0) || !isfinite(ask))
                {
                    ok = 0;
                    break;
                }
                qty = qty / ask;
            }
            if (!ok)
                continue;

            int last = row[n_legs - 1];
            int back = row[n_legs];
            double bid = e->mat.BID[matrix_idx(&e->mat, last, back)];
            if (!(bid > 0.0) || !isfinite(bid))
                continue;

            double fin = qty * bid;
            double pnl = fin - e->start_qty;
            if (!isfinite(pnl))
                continue;

            result_t r;
            r.route_id = route + 1;
            r.mid_i = 0;
            r.end_i = 0;
            r.final_base = fin;
            r.edge = (fin / e->start_qty) - 1.0;
            r.pnl = pnl;
            r.pct = (pnl / e->start_qty) * 100.0;
            r.ts_ns = ts;
            if (result_rb_t_push(&e->result_rb, &r))
            {
                e->results_emitted++;
            }
            else
            {
                e->results_dropped++;
            }
        }
    }
}

static void *engine_thread_main(void *p)
{
    engine_t *e = (engine_t *)p;

    while (atomic_load(&e->running))
    {
        tick_t t;
        int got = tick_rb_t_pop(&e->tick_rb, &t);
        if (!got)
        {
            struct timespec req;
            req.tv_sec = 0;
            req.tv_nsec = 200000; // 0.2 ms
            nanosleep(&req, NULL);
            continue;
        }

        int i0 = t.i_1b - 1;
        int j0 = t.j_1b - 1;
        matrix_update_pair(&e->mat, i0, j0, t.bid, t.ask);

        while (tick_rb_t_pop(&e->tick_rb, &t))
        {
            i0 = t.i_1b - 1;
            j0 = t.j_1b - 1;
            matrix_update_pair(&e->mat, i0, j0, t.bid, t.ask);
        }

        eval_all_routes(e);
    }
    return NULL;
}

// ---------- Public API ----------
static engine_t *engine_alloc_common(int n_ccy, int start_i_1b)
{
    if (n_ccy <= 1)
        return NULL;
    if (start_i_1b < 1 || start_i_1b > n_ccy)
        return NULL;

    engine_t *e = (engine_t *)calloc(1, sizeof(engine_t));
    if (!e)
        return NULL;

    e->n_ccy = n_ccy;
    e->start0 = start_i_1b - 1;
    e->start_qty = 100000.0;

    e->ticks_received  = 0;
    e->ticks_dropped   = 0;
    e->results_emitted = 0;
    e->results_dropped = 0;

    if (!matrix_init(&e->mat, n_ccy))
    {
        free(e);
        return NULL;
    }

    tick_rb_t_init(&e->tick_rb);
    result_rb_t_init(&e->result_rb);
    atomic_store(&e->running, 0);
    return e;
}

engine_t *engine_create_tri(int n_ccy, int start_i_1b,
                            const int *mid_end_rowmajor, int n_routes,
                            int one_based)
{
    engine_t *e = engine_alloc_common(n_ccy, start_i_1b);
    if (!e)
        return NULL;

    if (!routes_init_tri(&e->routes, mid_end_rowmajor, n_routes, one_based))
    {
        engine_destroy(e);
        return NULL;
    }
    return e;
}

engine_t *engine_create_cycle(int n_ccy, int start_i_1b,
                              const int *nodes_rowmajor, int n_routes, int n_cols,
                              int one_based)
{
    engine_t *e = engine_alloc_common(n_ccy, start_i_1b);
    if (!e)
        return NULL;

    if (!routes_init_cycle(&e->routes, nodes_rowmajor, n_routes, n_cols, one_based))
    {
        engine_destroy(e);
        return NULL;
    }
    return e;
}

void engine_destroy(engine_t *e)
{
    if (!e)
        return;
    engine_stop(e);
    routes_free(&e->routes);
    matrix_free(&e->mat);
    free(e);
}

int engine_start(engine_t *e)
{
    if (!e)
        return 0;

    int expected = 0;
    if (!atomic_compare_exchange_strong(&e->running, &expected, 1))
        return 1;

    if (pthread_create(&e->thread, NULL, engine_thread_main, e) != 0)
    {
        atomic_store(&e->running, 0); // viktig fix
        return 0;
    }
    return 1;
}

void engine_stop(engine_t *e)
{
    if (!e)
        return;
    if (atomic_exchange(&e->running, 0))
    {
        (void)pthread_join(e->thread, NULL);
    }
}

int engine_push_tick(engine_t *e, int i_1b, int j_1b, double bid, double ask)
{
    if (!e)
        return 0;

    tick_t t;
    t.i_1b = i_1b;
    t.j_1b = j_1b;
    t.bid = bid;
    t.ask = ask;
    t.ts_ns = ticks_now_ns();

    int ok = tick_rb_t_push(&e->tick_rb, &t);
    if (ok) {
        e->ticks_received++;
    } else {
        e->ticks_dropped++;
    }
    return ok;
}
int engine_pop_result(engine_t *e, result_t *out)
{
    if (!e || !out)
        return 0;
    return result_rb_t_pop(&e->result_rb, out);
}


========================================
FILE: engine.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/engine.h
========================================
#pragma once
#include <stdint.h>
#include "ticks.h"
#include "results.h"

#ifdef __cplusplus
extern "C"
{
#endif

    typedef struct engine_t engine_t;

    // Constructors
    engine_t *engine_create_tri(int n_ccy, int start_i_1b,
                                const int *mid_end_rowmajor, int n_routes,
                                int one_based);

    engine_t *engine_create_cycle(int n_ccy, int start_i_1b,
                                  const int *nodes_rowmajor, int n_routes, int n_cols,
                                  int one_based);

    // Lifecycle
    void engine_destroy(engine_t *e);

    // Thread control
    int engine_start(engine_t *e);
    void engine_stop(engine_t *e);

    // Feed ticks
    int engine_push_tick(engine_t *e, int i_1b, int j_1b, double bid, double ask);

    // Pop results (non-blocking): returns 1 if popped, else 0
    int engine_pop_result(engine_t *e, result_t *out);

#ifdef __cplusplus
}
#endif


========================================
FILE: funksjoner.rb
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/funksjoner.rb
========================================
engine_load
precompute_route_idx
.engine_push_mats
engine_push_tick
engine_init
engine_refresh_mats
engine_reinit_if_needed
engine_poll_df
engine_tick_eval
engine_wrappers_ready
engine_push_tick


========================================
FILE: matrix.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/matrix.c
========================================
#include "matrix.h"
#include <stdlib.h>
#include <string.h>

static void *aligned_malloc64(size_t bytes)
{
    void *p = NULL;
    // posix_memalign works well on macOS
    if (posix_memalign(&p, 64, bytes) != 0)
        return NULL;
    return p;
}

int matrix_init(matrix_t *m, int n)
{
    if (!m || n <= 1)
        return 0;
    m->n = n;

    size_t N = (size_t)n * (size_t)n;
    size_t bytes = N * sizeof(double);

    m->M = (double *)aligned_malloc64(bytes);
    m->BID = (double *)aligned_malloc64(bytes);
    m->ASK = (double *)aligned_malloc64(bytes);
    if (!m->M || !m->BID || !m->ASK)
    {
        matrix_free(m);
        return 0;
    }

    memset(m->M, 0, bytes);
    memset(m->BID, 0, bytes);
    memset(m->ASK, 0, bytes);
    return 1;
}

void matrix_free(matrix_t *m)
{
    if (!m)
        return;
    free(m->M);
    m->M = NULL;
    free(m->BID);
    m->BID = NULL;
    free(m->ASK);
    m->ASK = NULL;
    m->n = 0;
}


========================================
FILE: matrix.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/matrix.h
========================================
#pragma once
#include <stddef.h>
#include <math.h>

#ifdef __cplusplus
extern "C"
{
#endif

    typedef struct matrix_t
    {
        int n;
        double *M;
        double *BID;
        double *ASK;
    } matrix_t;

    int matrix_init(matrix_t *m, int n);
    void matrix_free(matrix_t *m);

    static inline size_t matrix_idx(const matrix_t *m, int i0, int j0)
    {
        return (size_t)i0 * (size_t)m->n + (size_t)j0;
    }

    static inline void matrix_update_pair(matrix_t *m, int i0, int j0, double bid, double ask)
    {
        size_t k = matrix_idx(m, i0, j0);
        m->BID[k] = bid;
        m->ASK[k] = ask;

        if (bid > 0.0 && ask > 0.0)
        {
            double x = bid * ask;
            m->M[k] = (x > 0.0) ? sqrt(x) : 0.0;
        }
        else
        {
            m->M[k] = 0.0;
        }
    }

#ifdef __cplusplus
}
#endif


========================================
FILE: results.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/results.h
========================================
#pragma once
#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif

    typedef struct result_t
    {
        int route_id; // 1-based
        int mid_i;    // 1-based (for tri routes; 0 if N-leg not representable)
        int end_i;    // 1-based (for tri routes; 0 if N-leg not representable)
        double edge;
        double final_base;
        double pnl;
        double pct;
        uint64_t ts_ns;
    } result_t;

#ifdef __cplusplus
}
#endif


========================================
FILE: ringbuffer.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/ringbuffer.h
========================================
#pragma once
#include <stddef.h>
#include <stdatomic.h>

#ifdef __cplusplus
extern "C"
{
#endif

// SPSC ringbuffer (single-producer, single-consumer)
// Capacity is N, but usable slots are N-1 (classic ring).
#define RB_DEFINE(name, type, N)                                               \
    typedef struct name                                                        \
    {                                                                          \
        type buffer[(N)];                                                      \
        atomic_size_t head;                                                    \
        atomic_size_t tail;                                                    \
    } name;                                                                    \
                                                                               \
    static inline void name##_init(name *rb)                                   \
    {                                                                          \
        atomic_init(&rb->head, 0);                                             \
        atomic_init(&rb->tail, 0);                                             \
    }                                                                          \
                                                                               \
    static inline int name##_push(name *rb, const type *v)                     \
    {                                                                          \
        size_t h = atomic_load_explicit(&rb->head, memory_order_relaxed);      \
        size_t n = (h + 1) % (N);                                              \
        size_t t = atomic_load_explicit(&rb->tail, memory_order_acquire);      \
        if (n == t)                                                            \
            return 0;                                                          \
        rb->buffer[h] = *v;                                                    \
        atomic_store_explicit(&rb->head, n, memory_order_release);             \
        return 1;                                                              \
    }                                                                          \
                                                                               \
    static inline int name##_pop(name *rb, type *out)                          \
    {                                                                          \
        size_t t = atomic_load_explicit(&rb->tail, memory_order_relaxed);      \
        size_t h = atomic_load_explicit(&rb->head, memory_order_acquire);      \
        if (t == h)                                                            \
            return 0;                                                          \
        *out = rb->buffer[t];                                                  \
        atomic_store_explicit(&rb->tail, (t + 1) % (N), memory_order_release); \
        return 1;                                                              \
    }

#ifdef __cplusplus
}
#endif


========================================
FILE: routes.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/routes.c
========================================
#include "routes.h"
#include <stdlib.h>
#include <string.h>

void routes_free(routes_t *r)
{
    if (!r)
        return;
    free(r->mid0);
    r->mid0 = NULL;
    free(r->end0);
    r->end0 = NULL;
    free(r->nodes0);
    r->nodes0 = NULL;
    r->n_routes = 0;
    r->n_cols = 0;
    r->kind = 0;
}

int routes_init_tri(routes_t *r, const int *input_mid_end, int n_routes, int one_based)
{
    if (!r || !input_mid_end || n_routes <= 0)
        return 0;
    memset(r, 0, sizeof(*r));
    r->kind = ROUTES_KIND_TRI;
    r->n_routes = n_routes;

    r->mid0 = (int *)malloc((size_t)n_routes * sizeof(int));
    r->end0 = (int *)malloc((size_t)n_routes * sizeof(int));
    if (!r->mid0 || !r->end0)
    {
        routes_free(r);
        return 0;
    }

    for (int k = 0; k < n_routes; ++k)
    {
        int mid = input_mid_end[2 * k + 0];
        int end = input_mid_end[2 * k + 1];
        if (one_based)
        {
            mid--;
            end--;
        }
        r->mid0[k] = mid;
        r->end0[k] = end;
    }
    return 1;
}

int routes_init_cycle(routes_t *r, const int *nodes, int n_routes, int n_cols, int one_based)
{
    if (!r || !nodes || n_routes <= 0 || n_cols < 2)
        return 0;
    memset(r, 0, sizeof(*r));
    r->kind = ROUTES_KIND_CYCLE;
    r->n_routes = n_routes;
    r->n_cols = n_cols;

    size_t L = (size_t)n_routes * (size_t)n_cols;
    r->nodes0 = (int *)malloc(L * sizeof(int));
    if (!r->nodes0)
    {
        routes_free(r);
        return 0;
    }

    for (size_t i = 0; i < L; ++i)
    {
        int v = nodes[i];
        if (one_based)
            v--;
        r->nodes0[i] = v;
    }
    return 1;
}


========================================
FILE: routes.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/routes.h
========================================
#pragma once
#include <stddef.h>

#ifdef __cplusplus
extern "C"
{
#endif

    typedef enum routes_kind_t
    {
        ROUTES_KIND_TRI = 1,  // routes are (mid,end)
        ROUTES_KIND_CYCLE = 2 // general cycle nodes (N legs)
    } routes_kind_t;

    typedef struct routes_t
    {
        routes_kind_t kind;
        int n_routes;

        // TRI fast-path:
        int *mid0; // 0-based
        int *end0; // 0-based

        // General cycle:
        int n_cols;  // nodes per route row (>=2). legs = n_cols-1
        int *nodes0; // row-major, 0-based indices, length n_routes*n_cols
    } routes_t;

    void routes_free(routes_t *r);

    // Create TRI from mid/end row-major.
    // input_mid_end: length n_routes*2
    int routes_init_tri(routes_t *r, const int *input_mid_end, int n_routes, int one_based);

    // Create cycle from nodes row-major.
    // nodes: length n_routes*n_cols; columns = nodes per route (n_legs+1)
    // If one_based=1, converts to 0-based.
    int routes_init_cycle(routes_t *r, const int *nodes, int n_routes, int n_cols, int one_based);

#ifdef __cplusplus
}
#endif


========================================
FILE: Samle all kode i mappen.r
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/Samle all kode i mappen.r
========================================
DIR_PATH <- "/Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++"

combine_all_sources <- function(dir = DIR_PATH,
                                output = "ALL_CODE.txt") {
    # Finn ALLE entries i mappen
    entries <- list.files(dir, full.names = TRUE, recursive = FALSE)

    # Filtrer ut mapper
    files <- entries[file.info(entries)$isdir == FALSE]

    # Filtrer ogs√• ut output-filen slik at den ikke slukes av seg selv
    files <- files[basename(files) != output]

    if (!length(files)) stop("Ingen filer funnet i mappen.")

    # Funksjon for √• sjekke om filen er tekst (ikke bin√¶r)
    is_text_file <- function(path) {
        con <- file(path, "rb")
        on.exit(close(con))
        raw <- readBin(con, what = "raw", n = 2000)
        !any(raw == as.raw(0))
    }

    out_lines <- c()

    for (f in files) {
        if (!is_text_file(f)) {
            message(sprintf("‚ö†Ô∏è Hopper over bin√¶r fil: %s", basename(f)))
            next
        }

        message(sprintf("üìÑ Leser: %s", basename(f)))

        content <- readLines(f, warn = FALSE)

        block <- c(
            "",
            "========================================",
            paste0("FILE: ", basename(f)),
            paste0("PATH: ", f),
            "========================================",
            content,
            ""
        )

        out_lines <- c(out_lines, block)
    }

    writeLines(out_lines, con = file.path(dir, output))
    message(sprintf(
        "\n‚úÖ Ferdig! ALL_CODE.txt lagret i:\n%s/%s",
        dir, output
    ))

    invisible(TRUE)
}
combine_all_sources()


========================================
FILE: test_engine.py
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/test_engine.py
========================================
#!/usr/bin/env python3
# test_engine.py ‚Äî kj√∏r fra katalogen som inneholder engine_py.py og libengine_v4.dylib

from engine_py import Engine
import time
import os, sys

print("cwd:", os.getcwd())
print("engine_py exists:", os.path.exists(os.path.join(os.getcwd(), "engine_py.py")))
print("lib exists:", os.path.exists(os.path.join(os.getcwd(), "libengine_v4.dylib")))

try:
    eng = Engine(n_ccy=4, start_i_1b=1, routes_mid_end_1b=[(2,3)])
except Exception as e:
    print("FEIL ved opprettelse av Engine:", e)
    sys.exit(1)

started = eng.start()
print("started:", started)

# Push syntetiske ticks (bid, ask)
eng.push_tick(1, 2, 0.0, 1.1)   # start->mid : ask=1.1
eng.push_tick(2, 3, 0.0, 1.1)   # mid->end   : ask=1.1
eng.push_tick(3, 1, 1.25, 0.0)  # end->start : bid=1.25

time.sleep(0.05)   # gi motoren litt tid
print("poll:", eng.poll())

eng.stop()
eng.destroy()


========================================
FILE: ticks.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/ticks.c
========================================
#include "ticks.h"

#if defined(__APPLE__)
#include <mach/mach_time.h>
uint64_t ticks_now_ns(void)
{
    static mach_timebase_info_data_t tb = {0, 0};
    if (tb.denom == 0)
        (void)mach_timebase_info(&tb);
    uint64_t t = mach_absolute_time();
    // ns = t * numer/denom
    return (t * (uint64_t)tb.numer) / (uint64_t)tb.denom;
}
#else
#include <time.h>
uint64_t ticks_now_ns(void)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec * 1000000000ull + (uint64_t)ts.tv_nsec;
}
#endif


========================================
FILE: ticks.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/ticks.h
========================================
#pragma once
#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif

    typedef struct tick_t
    {
        int i_1b;
        int j_1b;
        double bid;
        double ask;
        uint64_t ts_ns;
    } tick_t;

    uint64_t ticks_now_ns(void);

#ifdef __cplusplus
}
#endif


========================================
FILE: v4 engine wrappers ussiker1r
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/v4 engine wrappers ussiker1r
========================================

# ============================================================
#  ENGINE WRAPPER FOR ENGINE v4 (TRI + CYCLE)
#  Komplett, korrekt og matchet til C-koden du ga meg
# ============================================================

# -----------------------------
# Load the shared library
# -----------------------------
engine_load <- function(path) {
  path <- normalizePath(path, mustWork = TRUE)
  dyn.load(path)
  invisible(TRUE)
}

# -----------------------------
# Create engine
# -----------------------------
engine_create <- function(routes_matrix, start_ccy_index, n_ccy) {
  stopifnot(is.matrix(routes_matrix))
  stopifnot(is.integer(routes_matrix))
  stopifnot(length(start_ccy_index) == 1L)
  stopifnot(length(n_ccy) == 1L)

  .Call(
    "engine_create",
    routes_matrix,
    as.integer(start_ccy_index),
    as.integer(n_ccy)
  )
}

# -----------------------------
# Start engine thread
# -----------------------------
engine_start <- function(ptr) {
  .Call("engine_start_R", ptr)
}

# -----------------------------
# Stop engine
# -----------------------------
engine_stop <- function(ptr) {
  .Call("engine_stop_R", ptr)
}

# -----------------------------
# Push a single tick
# -----------------------------
engine_push_tick <- function(ptr, i, j, bid, ask) {
  .Call(
    "engine_push_tick_R",
    ptr,
    as.integer(i),
    as.integer(j),
    as.numeric(bid),
    as.numeric(ask)
  )
}

# -----------------------------
# Fill engine with full matrix
# -----------------------------
engine_push_full <- function(ptr, M, BID, ASK) {
  n <- nrow(M)
  for (i in seq_len(n)) {
    for (j in seq_len(n)) {
      b <- BID[i, j]
      a <- ASK[i, j]
      if (is.finite(b) && is.finite(a) && b > 0 && a > 0) {
        engine_push_tick(ptr, i, j, b, a)
      }
    }
  }
  invisible(TRUE)
}

# -----------------------------
# Poll all results at once
# -----------------------------
engine_poll <- function(ptr) {
  .Call("engine_poll", ptr)
}

# -----------------------------
# Helper: build TRI routes
# (1-based mid/end)
# -----------------------------
build_tri_routes <- function(ccys, start_ccy) {
  s <- match(start_ccy, ccys)
  idx <- setdiff(seq_along(ccys), s)

  g <- expand.grid(mid = idx, end = idx)
  g <- g[g$mid != g$end, ]

  routes <- as.matrix(g)
  storage.mode(routes) <- "integer"
  routes
}

# -----------------------------
# Full initializer
# (state$ccys, state$M/BID/ASK already exist)
# -----------------------------
engine_init <- function(state, start_ccy) {

  start_i <- match(start_ccy, state$ccys)
  if (is.na(start_i)) stop("start_ccy not in state$ccys")

  # Build triangular routes
  routes <- build_tri_routes(state$ccys, start_ccy)

  state$routes <- routes

  # Create engine in C
  state$eng <- engine_create(
    routes_matrix = routes, 
    start_ccy_index = start_i,
    n_ccy = length(state$ccys)
  )

  # Push initial matrices
  engine_push_full(state$eng, state$M, state$BID, state$ASK)

  # Start computation thread
  engine_start(state$eng)

  state
}



==========================================================
üìÑ CMakeCache.txt
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/build/CMakeCache.txt
==========================================================
# This is the CMakeCache file.
# For build in directory: /Users/sigurdberner/Documents/FX_ARBITRAGE_FINALE copy/C++/build
# It was generated by CMake: /opt/homebrew/bin/cmake
# You can edit this file to change values found and used by cmake.
# If you do not want to change any of the values, simply exit the editor.
# If you do want to change a value, simply edit, save, and exit the editor.
# The syntax for the file is as follows:
# KEY:TYPE=VALUE
# KEY is the name of a variable in the cache.
# TYPE is a hint to GUIs for the type of VALUE, DO NOT EDIT TYPE!.
# VALUE is the current value for the KEY.

########################
# EXTERNAL cache entries
########################

//Path to a program.
CMAKE_ADDR2LINE:FILEPATH=CMAKE_ADDR2LINE-NOTFOUND

//Path to a program.
CMAKE_AR:FILEPATH=/usr/bin/ar

//Choose the type of build, options are: None Debug Release RelWithDebInfo
// MinSizeRel ...
CMAKE_BUILD_TYPE:STRING=

//Enable/Disable color output during build.
CMAKE_COLOR_MAKEFILE:BOOL=ON

//C compiler
CMAKE_C_COMPILER:FILEPATH=/usr/bin/cc

//Flags used by the C compiler during all build types.
CMAKE_C_FLAGS:STRING=

//Flags used by the C compiler during DEBUG builds.
CMAKE_C_FLAGS_DEBUG:STRING=-g

//Flags used by the C compiler during MINSIZEREL builds.
CMAKE_C_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG

//Flags used by the C compiler during RELEASE builds.
CMAKE_C_FLAGS_RELEASE:STRING=-O3 -DNDEBUG

//Flags used by the C compiler during RELWITHDEBINFO builds.
CMAKE_C_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG

//Path to a program.
CMAKE_DLLTOOL:FILEPATH=CMAKE_DLLTOOL-NOTFOUND

//Flags used by the linker during all build types.
CMAKE_EXE_LINKER_FLAGS:STRING=

//Flags used by the linker during DEBUG builds.
CMAKE_EXE_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during MINSIZEREL builds.
CMAKE_EXE_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during RELEASE builds.
CMAKE_EXE_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during RELWITHDEBINFO builds.
CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//Enable/Disable output of compile commands during generation.
CMAKE_EXPORT_COMPILE_COMMANDS:BOOL=

//Value Computed by CMake.
CMAKE_FIND_PACKAGE_REDIRECTS_DIR:STATIC=/Users/sigurdberner/Documents/FX_ARBITRAGE_FINALE copy/C++/build/CMakeFiles/pkgRedirects

//Path to a program.
CMAKE_INSTALL_NAME_TOOL:FILEPATH=/usr/bin/install_name_tool

//Install path prefix, prepended onto install directories.
CMAKE_INSTALL_PREFIX:PATH=/usr/local

//Path to a program.
CMAKE_LINKER:FILEPATH=/usr/bin/ld

//Path to a program.
CMAKE_MAKE_PROGRAM:FILEPATH=/usr/bin/make

//Flags used by the linker during the creation of modules during
// all build types.
CMAKE_MODULE_LINKER_FLAGS:STRING=

//Flags used by the linker during the creation of modules during
// DEBUG builds.
CMAKE_MODULE_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during the creation of modules during
// MINSIZEREL builds.
CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during the creation of modules during
// RELEASE builds.
CMAKE_MODULE_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during the creation of modules during
// RELWITHDEBINFO builds.
CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//Path to a program.
CMAKE_NM:FILEPATH=/usr/bin/nm

//Path to a program.
CMAKE_OBJCOPY:FILEPATH=CMAKE_OBJCOPY-NOTFOUND

//Path to a program.
CMAKE_OBJDUMP:FILEPATH=/usr/bin/objdump

//Build architectures for OSX
CMAKE_OSX_ARCHITECTURES:STRING=

//Minimum OS X version to target for deployment (at runtime); newer
// APIs weak linked. Set to empty string for default value.
CMAKE_OSX_DEPLOYMENT_TARGET:STRING=

//The product will be built against the headers and libraries located
// inside the indicated SDK.
CMAKE_OSX_SYSROOT:STRING=

//Value Computed by CMake
CMAKE_PROJECT_COMPAT_VERSION:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_DESCRIPTION:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_HOMEPAGE_URL:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_NAME:STATIC=engine_v4

//Path to a program.
CMAKE_RANLIB:FILEPATH=/usr/bin/ranlib

//Path to a program.
CMAKE_READELF:FILEPATH=CMAKE_READELF-NOTFOUND

//Flags used by the linker during the creation of shared libraries
// during all build types.
CMAKE_SHARED_LINKER_FLAGS:STRING=

//Flags used by the linker during the creation of shared libraries
// during DEBUG builds.
CMAKE_SHARED_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during the creation of shared libraries
// during MINSIZEREL builds.
CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during the creation of shared libraries
// during RELEASE builds.
CMAKE_SHARED_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during the creation of shared libraries
// during RELWITHDEBINFO builds.
CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//If set, runtime paths are not added when installing shared libraries,
// but are added when building.
CMAKE_SKIP_INSTALL_RPATH:BOOL=NO

//If set, runtime paths are not added when using shared libraries.
CMAKE_SKIP_RPATH:BOOL=NO

//Flags used by the archiver during the creation of static libraries
// during all build types.
CMAKE_STATIC_LINKER_FLAGS:STRING=

//Flags used by the archiver during the creation of static libraries
// during DEBUG builds.
CMAKE_STATIC_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the archiver during the creation of static libraries
// during MINSIZEREL builds.
CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the archiver during the creation of static libraries
// during RELEASE builds.
CMAKE_STATIC_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the archiver during the creation of static libraries
// during RELWITHDEBINFO builds.
CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//Path to a program.
CMAKE_STRIP:FILEPATH=/usr/bin/strip

//Path to a program.
CMAKE_TAPI:FILEPATH=/Library/Developer/CommandLineTools/usr/bin/tapi

//If this value is on, makefiles will be generated without the
// .SILENT directive, and all commands will be echoed to the console
// during the make.  This is useful for debugging only. With Visual
// Studio IDE projects all commands are done without /nologo.
CMAKE_VERBOSE_MAKEFILE:BOOL=FALSE

//Value Computed by CMake
engine_v4_BINARY_DIR:STATIC=/Users/sigurdberner/Documents/FX_ARBITRAGE_FINALE copy/C++/build

//Value Computed by CMake
engine_v4_IS_TOP_LEVEL:STATIC=ON

//Value Computed by CMake
engine_v4_SOURCE_DIR:STATIC=/Users/sigurdberner/Documents/FX_ARBITRAGE_FINALE copy/C++


########################
# INTERNAL cache entries
########################

//ADVANCED property for variable: CMAKE_ADDR2LINE
CMAKE_ADDR2LINE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_AR
CMAKE_AR-ADVANCED:INTERNAL=1
//This is the directory where this CMakeCache.txt was created
CMAKE_CACHEFILE_DIR:INTERNAL=/Users/sigurdberner/Documents/FX_ARBITRAGE_FINALE copy/C++/build
//Major version of cmake used to create the current loaded cache
CMAKE_CACHE_MAJOR_VERSION:INTERNAL=4
//Minor version of cmake used to create the current loaded cache
CMAKE_CACHE_MINOR_VERSION:INTERNAL=1
//Patch version of cmake used to create the current loaded cache
CMAKE_CACHE_PATCH_VERSION:INTERNAL=2
//ADVANCED property for variable: CMAKE_COLOR_MAKEFILE
CMAKE_COLOR_MAKEFILE-ADVANCED:INTERNAL=1
//Path to CMake executable.
CMAKE_COMMAND:INTERNAL=/opt/homebrew/bin/cmake
//Path to cpack program executable.
CMAKE_CPACK_COMMAND:INTERNAL=/opt/homebrew/bin/cpack
//Path to ctest program executable.
CMAKE_CTEST_COMMAND:INTERNAL=/opt/homebrew/bin/ctest
//ADVANCED property for variable: CMAKE_C_COMPILER
CMAKE_C_COMPILER-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS
CMAKE_C_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_DEBUG
CMAKE_C_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_MINSIZEREL
CMAKE_C_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_RELEASE
CMAKE_C_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_RELWITHDEBINFO
CMAKE_C_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_DLLTOOL
CMAKE_DLLTOOL-ADVANCED:INTERNAL=1
//Path to cache edit program executable.
CMAKE_EDIT_COMMAND:INTERNAL=/opt/homebrew/bin/ccmake
//Executable file format
CMAKE_EXECUTABLE_FORMAT:INTERNAL=MACHO
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS
CMAKE_EXE_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_DEBUG
CMAKE_EXE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_MINSIZEREL
CMAKE_EXE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELEASE
CMAKE_EXE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXPORT_COMPILE_COMMANDS
CMAKE_EXPORT_COMPILE_COMMANDS-ADVANCED:INTERNAL=1
//Name of external makefile project generator.
CMAKE_EXTRA_GENERATOR:INTERNAL=
//Name of generator.
CMAKE_GENERATOR:INTERNAL=Unix Makefiles
//Generator instance identifier.
CMAKE_GENERATOR_INSTANCE:INTERNAL=
//Name of generator platform.
CMAKE_GENERATOR_PLATFORM:INTERNAL=
//Name of generator toolset.
CMAKE_GENERATOR_TOOLSET:INTERNAL=
//Source directory with the top level CMakeLists.txt file for this
// project
CMAKE_HOME_DIRECTORY:INTERNAL=/Users/sigurdberner/Documents/FX_ARBITRAGE_FINALE copy/C++
//ADVANCED property for variable: CMAKE_INSTALL_NAME_TOOL
CMAKE_INSTALL_NAME_TOOL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_LINKER
CMAKE_LINKER-ADVANCED:INTERNAL=1
//Name of CMakeLists files to read
CMAKE_LIST_FILE_NAME:INTERNAL=CMakeLists.txt
//ADVANCED property for variable: CMAKE_MAKE_PROGRAM
CMAKE_MAKE_PROGRAM-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS
CMAKE_MODULE_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_DEBUG
CMAKE_MODULE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL
CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELEASE
CMAKE_MODULE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_NM
CMAKE_NM-ADVANCED:INTERNAL=1
//number of local generators
CMAKE_NUMBER_OF_MAKEFILES:INTERNAL=1
//ADVANCED property for variable: CMAKE_OBJCOPY
CMAKE_OBJCOPY-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_OBJDUMP
CMAKE_OBJDUMP-ADVANCED:INTERNAL=1
//Platform information initialized
CMAKE_PLATFORM_INFO_INITIALIZED:INTERNAL=1
//ADVANCED property for variable: CMAKE_RANLIB
CMAKE_RANLIB-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_READELF
CMAKE_READELF-ADVANCED:INTERNAL=1
//Path to CMake installation.
CMAKE_ROOT:INTERNAL=/opt/homebrew/share/cmake
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS
CMAKE_SHARED_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_DEBUG
CMAKE_SHARED_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL
CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELEASE
CMAKE_SHARED_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SKIP_INSTALL_RPATH
CMAKE_SKIP_INSTALL_RPATH-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SKIP_RPATH
CMAKE_SKIP_RPATH-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS
CMAKE_STATIC_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_DEBUG
CMAKE_STATIC_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL
CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELEASE
CMAKE_STATIC_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STRIP
CMAKE_STRIP-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_TAPI
CMAKE_TAPI-ADVANCED:INTERNAL=1
//uname command
CMAKE_UNAME:INTERNAL=/usr/bin/uname
//ADVANCED property for variable: CMAKE_VERBOSE_MAKEFILE
CMAKE_VERBOSE_MAKEFILE-ADVANCED:INTERNAL=1



==========================================================
üìÑ apple-sdk.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/build/CMakeFiles/4.1.2/CompilerIdC/apple-sdk.c
==========================================================
#include <AvailabilityMacros.h>


==========================================================
üìÑ CMakeCCompilerId.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/build/CMakeFiles/4.1.2/CompilerIdC/CMakeCCompilerId.c
==========================================================
#ifdef __cplusplus
# error "A C++ compiler has been selected for C."
#endif

#if defined(__18CXX)
# define ID_VOID_MAIN
#endif
#if defined(__CLASSIC_C__)
/* cv-qualifiers did not exist in K&R C */
# define const
# define volatile
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif
#if defined(__GNUC_MINOR__)
# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#endif
#if defined(__GNUC_PATCHLEVEL__)
# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_C)
# define COMPILER_ID "SunPro"
# if __SUNPRO_C >= 0x5100
   /* __SUNPRO_C = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
# endif

#elif defined(__HP_cc)
# define COMPILER_ID "HP"
  /* __HP_cc = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_cc/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_cc/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_cc     % 100)

#elif defined(__DECC)
# define COMPILER_ID "Compaq"
  /* __DECC_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECC_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECC_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECC_VER         % 10000)

#elif defined(__IBMC__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__open_xl__) && defined(__clang__)
# define COMPILER_ID "IBMClang"
# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)
# define COMPILER_VERSION_INTERNAL_STR  __clang_version__


#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ >= 800
# define COMPILER_ID "XL"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__NVCOMPILER)
# define COMPILER_ID "NVHPC"
# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
# if defined(__NVCOMPILER_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(__clang__) && defined(__cray__)
# define COMPILER_ID "CrayClang"
# define COMPILER_VERSION_MAJOR DEC(__cray_major__)
# define COMPILER_VERSION_MINOR DEC(__cray_minor__)
# define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__CLANG_FUJITSU)
# define COMPILER_ID "FujitsuClang"
# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(__FUJITSU)
# define COMPILER_ID "Fujitsu"
# if defined(__FCC_version__)
#   define COMPILER_VERSION __FCC_version__
# elif defined(__FCC_major__)
#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# endif
# if defined(__fcc_version)
#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
# elif defined(__FCC_VERSION)
#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
# endif


#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__TASKING__)
# define COMPILER_ID "Tasking"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION__/1000)
  # define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
# define COMPILER_VERSION_INTERNAL DEC(__VERSION__)

#elif defined(__ORANGEC__)
# define COMPILER_ID "OrangeC"
# define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
# define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)

#elif defined(__RENESAS__)
# define COMPILER_ID "Renesas"
/* __RENESAS_VERSION__ = 0xVVRRPP00 */
# define COMPILER_VERSION_MAJOR HEX(__RENESAS_VERSION__ >> 24 & 0xFF)
# define COMPILER_VERSION_MINOR HEX(__RENESAS_VERSION__ >> 16 & 0xFF)
# define COMPILER_VERSION_PATCH HEX(__RENESAS_VERSION__ >> 8  & 0xFF)

#elif defined(__TINYC__)
# define COMPILER_ID "TinyCC"

#elif defined(__BCC__)
# define COMPILER_ID "Bruce"

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION/100   % 100)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__) && defined(__ti__)
# define COMPILER_ID "TIClang"
  # define COMPILER_VERSION_MAJOR DEC(__ti_major__)
  # define COMPILER_VERSION_MINOR DEC(__ti_minor__)
  # define COMPILER_VERSION_PATCH DEC(__ti_patchlevel__)
# define COMPILER_VERSION_INTERNAL DEC(__ti_version__)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
# define COMPILER_ID "LCC"
# define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
# define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
# if defined(__LCC_MINOR__)
#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
# endif
# if defined(__GNUC__) && defined(__GNUC_MINOR__)
#  define SIMULATE_ID "GNU"
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#  if defined(__GNUC_PATCHLEVEL__)
#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#  endif
# endif

#elif defined(__GNUC__)
# define COMPILER_ID "GNU"
# define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(_ADI_COMPILER)
# define COMPILER_ID "ADSP"
#if defined(__VERSIONNUM__)
  /* __VERSIONNUM__ = 0xVVRRPPTT */
#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif

#elif defined(__DCC__) && defined(_DIAB_TOOL)
# define COMPILER_ID "Diab"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION_MAJOR_NUMBER__)
  # define COMPILER_VERSION_MINOR DEC(__VERSION_MINOR_NUMBER__)
  # define COMPILER_VERSION_PATCH DEC(__VERSION_ARCH_FEATURE_NUMBER__)
  # define COMPILER_VERSION_TWEAK DEC(__VERSION_BUG_FIX_NUMBER__)


#elif defined(__SDCC_VERSION_MAJOR) || defined(SDCC)
# define COMPILER_ID "SDCC"
# if defined(__SDCC_VERSION_MAJOR)
#  define COMPILER_VERSION_MAJOR DEC(__SDCC_VERSION_MAJOR)
#  define COMPILER_VERSION_MINOR DEC(__SDCC_VERSION_MINOR)
#  define COMPILER_VERSION_PATCH DEC(__SDCC_VERSION_PATCH)
# else
  /* SDCC = VRP */
#  define COMPILER_VERSION_MAJOR DEC(SDCC/100)
#  define COMPILER_VERSION_MINOR DEC(SDCC/10 % 10)
#  define COMPILER_VERSION_PATCH DEC(SDCC    % 10)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__MSYS__)
# define PLATFORM_ID "MSYS"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# elif defined(__VXWORKS__)
#  define PLATFORM_ID "VxWorks"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

# elif defined(_ADI_COMPILER)
#  define PLATFORM_ID "ADSP"

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_ARM64EC)
#  define ARCHITECTURE_ID "ARM64EC"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__ICCSTM8__)
#  define ARCHITECTURE_ID "STM8"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__clang__) && defined(__ti__)
# if defined(__ARM_ARCH)
#  define ARCHITECTURE_ID "ARM"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__TI_COMPILER_VERSION__)
# if defined(__TI_ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__MSP430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__TMS320C28XX__)
#  define ARCHITECTURE_ID "TMS320C28x"

# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
#  define ARCHITECTURE_ID "TMS320C6x"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

# elif defined(__ADSPSHARC__)
#  define ARCHITECTURE_ID "SHARC"

# elif defined(__ADSPBLACKFIN__)
#  define ARCHITECTURE_ID "Blackfin"

#elif defined(__TASKING__)

# if defined(__CTC__) || defined(__CPTC__)
#  define ARCHITECTURE_ID "TriCore"

# elif defined(__CMCS__)
#  define ARCHITECTURE_ID "MCS"

# elif defined(__CARM__) || defined(__CPARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__CARC__)
#  define ARCHITECTURE_ID "ARC"

# elif defined(__C51__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__CPCP__)
#  define ARCHITECTURE_ID "PCP"

# else
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__RENESAS__)
# if defined(__CCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__CCRL__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__CCRH__)
#  define ARCHITECTURE_ID "RH850"

# else
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number. */
#ifdef COMPILER_VERSION
char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";

/* Construct a string literal encoding the version number components. */
#elif defined(COMPILER_VERSION_MAJOR)
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#elif defined(COMPILER_VERSION_INTERNAL_STR)
char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



#define C_STD_99 199901L
#define C_STD_11 201112L
#define C_STD_17 201710L
#define C_STD_23 202311L

#ifdef __STDC_VERSION__
#  define C_STD __STDC_VERSION__
#endif

#if !defined(__STDC__) && !defined(__clang__) && !defined(__RENESAS__)
# if defined(_MSC_VER) || defined(__ibmxl__) || defined(__IBMC__)
#  define C_VERSION "90"
# else
#  define C_VERSION
# endif
#elif C_STD > C_STD_17
# define C_VERSION "23"
#elif C_STD > C_STD_11
# define C_VERSION "17"
#elif C_STD > C_STD_99
# define C_VERSION "11"
#elif C_STD >= C_STD_99
# define C_VERSION "99"
#else
# define C_VERSION "90"
#endif
const char* info_language_standard_default =
  "INFO" ":" "standard_default[" C_VERSION "]";

const char* info_language_extensions_default = "INFO" ":" "extensions_default["
#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
     defined(__TI_COMPILER_VERSION__) || defined(__RENESAS__)) &&             \
  !defined(__STRICT_ANSI__)
  "ON"
#else
  "OFF"
#endif
"]";

/*--------------------------------------------------------------------------*/

#ifdef ID_VOID_MAIN
void main() {}
#else
# if defined(__CLASSIC_C__)
int main(argc, argv) int argc; char *argv[];
# else
int main(int argc, char* argv[])
# endif
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#if defined(COMPILER_VERSION_INTERNAL) || defined(COMPILER_VERSION_INTERNAL_STR)
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
  require += info_cray[argc];
#endif
  require += info_language_standard_default[argc];
  require += info_language_extensions_default[argc];
  (void)argv;
  return require;
}
#endif


==========================================================
üìÑ link.txt
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/build/CMakeFiles/engine_v4.dir/link.txt
==========================================================
/usr/bin/cc  -arch arm64 -Wl,-undefined,dynamic_lookup -dynamiclib -Wl,-headerpad_max_install_names -o libengine_v4.dylib -install_name @rpath/libengine_v4.dylib CMakeFiles/engine_v4.dir/engine.c.o CMakeFiles/engine_v4.dir/engine_R.c.o CMakeFiles/engine_v4.dir/routes.c.o CMakeFiles/engine_v4.dir/matrix.c.o CMakeFiles/engine_v4.dir/ticks.c.o


==========================================================
üìÑ TargetDirectories.txt
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/build/CMakeFiles/TargetDirectories.txt
==========================================================
/Users/sigurdberner/Documents/FX_ARBITRAGE_FINALE copy/C++/build/CMakeFiles/engine_v4.dir
/Users/sigurdberner/Documents/FX_ARBITRAGE_FINALE copy/C++/build/CMakeFiles/edit_cache.dir
/Users/sigurdberner/Documents/FX_ARBITRAGE_FINALE copy/C++/build/CMakeFiles/rebuild_cache.dir


==========================================================
üìÑ CMakeLists.txt
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/CMakeLists.txt
==========================================================
cmake_minimum_required(VERSION 3.16)
project(engine_v4 C)

set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

# macOS: allow unresolved symbols for R
if(APPLE)
    set(CMAKE_C_VISIBILITY_PRESET default)
    set(CMAKE_VISIBILITY_INLINES_HIDDEN OFF)
endif()

# ---- Finn R include path ----
execute_process(
  COMMAND R RHOME
  OUTPUT_VARIABLE R_HOME
  OUTPUT_STRIP_TRAILING_WHITESPACE
)

set(R_INCLUDE_DIR "${R_HOME}/include")

# ---- Kilder ----
set(SRC
    engine.c
    engine_R.c
    routes.c
    matrix.c
    ticks.c
)

add_library(engine_v4 SHARED ${SRC})

# ---- Include dirs ----
target_include_directories(engine_v4 PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${R_INCLUDE_DIR}
)

# ---- macOS: dynamic lookup ----
if(APPLE)
    target_link_options(engine_v4 PRIVATE "-Wl,-undefined,dynamic_lookup")
endif()

# ---- Optimalisering ----
if (CMAKE_C_COMPILER_ID MATCHES "Clang|AppleClang|GNU")
    target_compile_options(engine_v4 PRIVATE -O3 -march=native)
endif()

set_target_properties(engine_v4 PROPERTIES OUTPUT_NAME "engine_v4")


==========================================================
üìÑ engine_py.py
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/engine_py.py
==========================================================
import ctypes
import os
import sys

# Adjust name if you build different
if sys.platform == "darwin":
    LIBNAME = "libengine_v4.dylib"
elif sys.platform.startswith("linux"):
    LIBNAME = "libengine_v4.so"
else:
    raise RuntimeError("Unsupported platform")

_here = os.path.dirname(os.path.abspath(__file__))
_libpath = os.path.join(_here, LIBNAME)

lib = ctypes.CDLL(_libpath)

# ---- signatures ----
lib.engine_create_tri.restype = ctypes.c_void_p
lib.engine_create_tri.argtypes = [
    ctypes.c_int, ctypes.c_int,
    ctypes.POINTER(ctypes.c_int), ctypes.c_int,
    ctypes.c_int
]

lib.engine_start.restype = ctypes.c_int
lib.engine_start.argtypes = [ctypes.c_void_p]

lib.engine_stop.restype = None
lib.engine_stop.argtypes = [ctypes.c_void_p]

lib.engine_destroy.restype = None
lib.engine_destroy.argtypes = [ctypes.c_void_p]

lib.engine_push_tick.restype = ctypes.c_int
lib.engine_push_tick.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_int, ctypes.c_double, ctypes.c_double]

class Result(ctypes.Structure):
    _fields_ = [
        ("route_id", ctypes.c_int),
        ("mid_i", ctypes.c_int),
        ("end_i", ctypes.c_int),
        ("edge", ctypes.c_double),
        ("final_base", ctypes.c_double),
        ("pnl", ctypes.c_double),
        ("pct", ctypes.c_double),
        ("ts_ns", ctypes.c_uint64),
    ]

lib.engine_pop_result.restype = ctypes.c_int
lib.engine_pop_result.argtypes = [ctypes.c_void_p, ctypes.POINTER(Result)]

class Engine:
    def __init__(self, n_ccy, start_i_1b, routes_mid_end_1b):
        # routes_mid_end_1b: list of (mid,end) 1-based
        flat = []
        for mid, end in routes_mid_end_1b:
            flat.extend([mid, end])
        arr = (ctypes.c_int * len(flat))(*flat)
        self._eng = lib.engine_create_tri(n_ccy, start_i_1b, arr, len(routes_mid_end_1b), 1)
        if not self._eng:
            raise RuntimeError("engine_create_tri failed")

    def start(self):
        return bool(lib.engine_start(self._eng))

    def stop(self):
        lib.engine_stop(self._eng)

    def destroy(self):
        if self._eng:
            lib.engine_destroy(self._eng)
            self._eng = None

    def push_tick(self, i_1b, j_1b, bid, ask):
        return bool(lib.engine_push_tick(self._eng, i_1b, j_1b, float(bid), float(ask)))

    def poll(self):
        out = []
        r = Result()
        while lib.engine_pop_result(self._eng, ctypes.byref(r)):
            out.append({
                "route_id": r.route_id,
                "mid": r.mid_i,
                "end": r.end_i,
                "pnl": r.pnl,
                "edge": r.edge,
                "final_base": r.final_base,
                "pct": r.pct,
                "ts_ns": int(r.ts_ns),
            })
        return out


==========================================================
üìÑ engine_R.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/engine_R.c
==========================================================
#include <R.h>
#include <Rinternals.h>
#include <stdint.h>
#include <stdlib.h>

#include "engine.h"
#include "results.h"

// finalizer
static void engine_xptr_finalizer(SEXP xptr)
{
    engine_t *eng = (engine_t *)R_ExternalPtrAddr(xptr);
    if (eng)
    {
        engine_stop(eng);
        engine_destroy(eng);
        R_ClearExternalPtr(xptr);
    }
}

// R integer matrix is column-major; convert to row-major int*
static int *int_matrix_to_rowmajor(SEXP mat, int *out_nrow, int *out_ncol)
{
    if (!isInteger(mat) || !isMatrix(mat))
        error("routes must be an integer matrix");

    SEXP dim = getAttrib(mat, R_DimSymbol);
    int nrow = INTEGER(dim)[0];
    int ncol = INTEGER(dim)[1];
    if (nrow <= 0 || ncol <= 0)
        error("routes has invalid dimensions");

    int *src = INTEGER(mat);
    int *dst = (int *)malloc((size_t)nrow * (size_t)ncol * sizeof(int));
    if (!dst)
        error("malloc failed");

    for (int r = 0; r < nrow; ++r)
    {
        for (int c = 0; c < ncol; ++c)
        {
            dst[(size_t)r * (size_t)ncol + (size_t)c] = src[r + nrow * c];
        }
    }

    *out_nrow = nrow;
    *out_ncol = ncol;
    return dst;
}

// .Call engine_create(routes, start_i_1b, n_ccy)
// routes:
//   - if ncol==2 => TRI routes (mid,end) 1-based
//   - if ncol>=3 => cycle nodes (N legs) 1-based
SEXP engine_create(SEXP routes, SEXP start_i_1b, SEXP n_ccy)
{
    if (!isInteger(start_i_1b) || LENGTH(start_i_1b) != 1)
        error("start_i_1b must be integer(1)");
    if (!isInteger(n_ccy) || LENGTH(n_ccy) != 1)
        error("n_ccy must be integer(1)");

    int start = INTEGER(start_i_1b)[0];
    int n = INTEGER(n_ccy)[0];

    int nrow = 0, ncol = 0;
    int *rowmajor = int_matrix_to_rowmajor(routes, &nrow, &ncol);

    engine_t *eng = NULL;
    if (ncol == 2)
    {
        eng = engine_create_tri(n, start, rowmajor, nrow, /*one_based=*/1);
    }
    else if (ncol >= 3)
    {
        eng = engine_create_cycle(n, start, rowmajor, nrow, ncol, /*one_based=*/1);
    }
    else
    {
        free(rowmajor);
        error("routes must have at least 2 columns");
    }

    free(rowmajor);
    if (!eng)
        error("engine_create failed");

    SEXP xptr = PROTECT(R_MakeExternalPtr((void *)eng, R_NilValue, R_NilValue));
    R_RegisterCFinalizerEx(xptr, engine_xptr_finalizer, 1);
    UNPROTECT(1);
    return xptr;
}

SEXP engine_start_R(SEXP xptr)
{
    engine_t *eng = (engine_t *)R_ExternalPtrAddr(xptr);
    if (!eng)
        error("engine ptr is null");
    return ScalarLogical(engine_start(eng) ? 1 : 0);
}

SEXP engine_stop_R(SEXP xptr)
{
    engine_t *eng = (engine_t *)R_ExternalPtrAddr(xptr);
    if (!eng)
        return R_NilValue;
    engine_stop(eng);
    return R_NilValue;
}

SEXP engine_push_tick_R(SEXP xptr, SEXP i_1b, SEXP j_1b, SEXP bid, SEXP ask)
{
    engine_t *eng = (engine_t *)R_ExternalPtrAddr(xptr);
    if (!eng)
        error("engine ptr is null");

    if (!isInteger(i_1b) || LENGTH(i_1b) != 1)
        error("i_1b must be integer(1)");
    if (!isInteger(j_1b) || LENGTH(j_1b) != 1)
        error("j_1b must be integer(1)");
    if (!isReal(bid) || LENGTH(bid) != 1)
        error("bid must be double(1)");
    if (!isReal(ask) || LENGTH(ask) != 1)
        error("ask must be double(1)");

    int i = INTEGER(i_1b)[0];
    int j = INTEGER(j_1b)[0];
    double b = REAL(bid)[0];
    double a = REAL(ask)[0];

    return ScalarLogical(engine_push_tick(eng, i, j, b, a) ? 1 : 0);
}

SEXP engine_poll(SEXP xptr)
{
    engine_t *eng = (engine_t *)R_ExternalPtrAddr(xptr);
    if (!eng)
        error("engine ptr is null");

    // dynamic accumulate
    size_t cap = 1024, n = 0;
    int *route_id = (int *)malloc(cap * sizeof(int));
    int *mid_i = (int *)malloc(cap * sizeof(int));
    int *end_i = (int *)malloc(cap * sizeof(int));
    double *pnl = (double *)malloc(cap * sizeof(double));
    double *edge = (double *)malloc(cap * sizeof(double));
    double *fin = (double *)malloc(cap * sizeof(double));
    double *pct = (double *)malloc(cap * sizeof(double));
    double *ts = (double *)malloc(cap * sizeof(double));

    if (!route_id || !mid_i || !end_i || !pnl || !edge || !fin || !pct || !ts)
    {
        free(route_id);
        free(mid_i);
        free(end_i);
        free(pnl);
        free(edge);
        free(fin);
        free(pct);
        free(ts);
        error("malloc failed");
    }

    result_t r;
    while (engine_pop_result(eng, &r))
    {
        if (n == cap)
        {
            cap *= 2;
            route_id = (int *)realloc(route_id, cap * sizeof(int));
            mid_i = (int *)realloc(mid_i, cap * sizeof(int));
            end_i = (int *)realloc(end_i, cap * sizeof(int));
            pnl = (double *)realloc(pnl, cap * sizeof(double));
            edge = (double *)realloc(edge, cap * sizeof(double));
            fin = (double *)realloc(fin, cap * sizeof(double));
            pct = (double *)realloc(pct, cap * sizeof(double));
            ts = (double *)realloc(ts, cap * sizeof(double));
            if (!route_id || !mid_i || !end_i || !pnl || !edge || !fin || !pct || !ts)
                error("realloc failed");
        }
        route_id[n] = r.route_id;
        mid_i[n] = r.mid_i;
        end_i[n] = r.end_i;
        pnl[n] = r.pnl;
        edge[n] = r.edge;
        fin[n] = r.final_base;
        pct[n] = r.pct;
        ts[n] = (double)r.ts_ns;
        n++;
    }

    SEXP Route = PROTECT(allocVector(INTSXP, (R_xlen_t)n));
    SEXP Mid = PROTECT(allocVector(INTSXP, (R_xlen_t)n));
    SEXP End = PROTECT(allocVector(INTSXP, (R_xlen_t)n));
    SEXP Pnl = PROTECT(allocVector(REALSXP, (R_xlen_t)n));
    SEXP Edge = PROTECT(allocVector(REALSXP, (R_xlen_t)n));
    SEXP Fin = PROTECT(allocVector(REALSXP, (R_xlen_t)n));
    SEXP Pct = PROTECT(allocVector(REALSXP, (R_xlen_t)n));
    SEXP Ts = PROTECT(allocVector(REALSXP, (R_xlen_t)n));

    for (size_t i = 0; i < n; ++i)
    {
        INTEGER(Route)
        [i] = route_id[i];
        INTEGER(Mid)
        [i] = mid_i[i];
        INTEGER(End)
        [i] = end_i[i];
        REAL(Pnl)
        [i] = pnl[i];
        REAL(Edge)
        [i] = edge[i];
        REAL(Fin)
        [i] = fin[i];
        REAL(Pct)
        [i] = pct[i];
        REAL(Ts)
        [i] = ts[i];
    }

    free(route_id);
    free(mid_i);
    free(end_i);
    free(pnl);
    free(edge);
    free(fin);
    free(pct);
    free(ts);

    SEXP df = PROTECT(allocVector(VECSXP, 8));
    SET_VECTOR_ELT(df, 0, Route);
    SET_VECTOR_ELT(df, 1, Mid);
    SET_VECTOR_ELT(df, 2, End);
    SET_VECTOR_ELT(df, 3, Pnl);
    SET_VECTOR_ELT(df, 4, Edge);
    SET_VECTOR_ELT(df, 5, Fin);
    SET_VECTOR_ELT(df, 6, Pct);
    SET_VECTOR_ELT(df, 7, Ts);

    SEXP names = PROTECT(allocVector(STRSXP, 8));
    SET_STRING_ELT(names, 0, mkChar("route_id"));
    SET_STRING_ELT(names, 1, mkChar("mid"));
    SET_STRING_ELT(names, 2, mkChar("end"));
    SET_STRING_ELT(names, 3, mkChar("pnl"));
    SET_STRING_ELT(names, 4, mkChar("edge"));
    SET_STRING_ELT(names, 5, mkChar("final_base"));
    SET_STRING_ELT(names, 6, mkChar("pct"));
    SET_STRING_ELT(names, 7, mkChar("ts_ns"));
    setAttrib(df, R_NamesSymbol, names);

    SEXP rownames = PROTECT(allocVector(INTSXP, 2));
    INTEGER(rownames)
    [0] = NA_INTEGER;
    INTEGER(rownames)
    [1] = (int)n;
    setAttrib(df, R_RowNamesSymbol, rownames);

    setAttrib(df, R_ClassSymbol, mkString("data.frame"));

    UNPROTECT(11);
    return df;
}
#include <R_ext/Rdynload.h>

static const R_CallMethodDef callMethods[] = {
    {"engine_create", (DL_FUNC)&engine_create, 3},
    {"engine_start_R", (DL_FUNC)&engine_start_R, 1},
    {"engine_stop_R", (DL_FUNC)&engine_stop_R, 1},
    {"engine_push_tick_R", (DL_FUNC)&engine_push_tick_R, 5},
    {"engine_poll", (DL_FUNC)&engine_poll, 1},
    {NULL, NULL, 0}};

void R_init_engine_v4(DllInfo *dll)
{
    R_registerRoutines(dll, NULL, callMethods, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}


==========================================================
üìÑ engine.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/engine.c
==========================================================
#include "engine.h"
#include "matrix.h"
#include "ringbuffer.h"
#include "routes.h"

#include <pthread.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

// Fixed ring sizes (A: fixed lock-free ringbuffer)
RB_DEFINE(tick_rb_t, tick_t, 8192)
RB_DEFINE(result_rb_t, result_t, 8192)

struct engine_t
{
    int n_ccy;
    int start0; // 0-based

    matrix_t mat;
    routes_t routes;

    // Threading
    _Atomic int running;
    pthread_t thread;

    // Buffers
    tick_rb_t tick_rb;
    result_rb_t result_rb;

    // Telemetry
    uint64_t ticks_received;
    uint64_t ticks_dropped;
    uint64_t results_emitted;
    uint64_t results_dropped;

    // scratch (avoid malloc each eval)
    double start_qty;
};

// ---------- Engine core math ----------
// TRI semantics matches din gamle engine:
// qty_mid = start_qty / ASK[start, mid]
// qty_end = qty_mid / ASK[mid, end]
// final   = qty_end * BID[end, start]
static inline int tri_simulate(const matrix_t *mat, int start0, int mid0, int end0,
                               double start_qty,
                               double *final_base, double *edge_out, double *pnl_out)
{
    size_t idx1 = matrix_idx(mat, start0, mid0);
    size_t idx2 = matrix_idx(mat, mid0, end0);
    size_t idx3 = matrix_idx(mat, end0, start0);

    double ask1 = mat->ASK[idx1];
    if (!(ask1 > 0.0) || !isfinite(ask1))
        return 0;
    double qty_mid = start_qty / ask1;

    double ask2 = mat->ASK[idx2];
    if (!(ask2 > 0.0) || !isfinite(ask2))
        return 0;
    double qty_end = qty_mid / ask2;

    double bid3 = mat->BID[idx3];
    if (!(bid3 > 0.0) || !isfinite(bid3))
        return 0;

    double fin = qty_end * bid3;
    double pnl = fin - start_qty;
    double edge = (fin / start_qty) - 1.0;

    *final_base = fin;
    *pnl_out = pnl;
    *edge_out = edge;
    return isfinite(pnl) ? 1 : 0;
}

static void eval_all_routes(engine_t *e)
{
    const int R = e->routes.n_routes;
    const uint64_t ts = ticks_now_ns();

    if (e->routes.kind == ROUTES_KIND_TRI)
    {
        int k = 0;
        for (; k + 3 < R; k += 4)
        {
            for (int u = 0; u < 4; ++u)
            {
                int kk = k + u;
                int mid0 = e->routes.mid0[kk];
                int end0 = e->routes.end0[kk];

                double fin, edge, pnl;
                if (tri_simulate(&e->mat, e->start0, mid0, end0, e->start_qty, &fin, &edge, &pnl))
                {
                    result_t r;
                    r.route_id = kk + 1;
                    r.mid_i = mid0 + 1;
                    r.end_i = end0 + 1;
                    r.final_base = fin;
                    r.edge = edge;
                    r.pnl = pnl;
                    r.pct = (pnl / e->start_qty) * 100.0;
                    r.ts_ns = ts;
                    if (result_rb_t_push(&e->result_rb, &r))
                    {
                        e->results_emitted++;
                    }
                    else
                    {
                        e->results_dropped++;
                    }
                }
            }
        }
        for (; k < R; ++k)
        {
            int mid0 = e->routes.mid0[k];
            int end0 = e->routes.end0[k];

            double fin, edge, pnl;
            if (tri_simulate(&e->mat, e->start0, mid0, end0, e->start_qty, &fin, &edge, &pnl))
            {
                result_t r;
                r.route_id = k + 1;
                r.mid_i = mid0 + 1;
                r.end_i = end0 + 1;
                r.final_base = fin;
                r.edge = edge;
                r.pnl = pnl;
                r.pct = (pnl / e->start_qty) * 100.0;
                r.ts_ns = ts;
                if (result_rb_t_push(&e->result_rb, &r))
                {
                    e->results_emitted++;
                }
                else
                {
                    e->results_dropped++;
                }
            }
        }
        return;
    }

    if (e->routes.kind == ROUTES_KIND_CYCLE)
    {
        const int n_cols = e->routes.n_cols;
        const int n_legs = n_cols - 1;

        for (int route = 0; route < R; ++route)
        {
            const int *row = &e->routes.nodes0[(size_t)route * (size_t)n_cols];

            double qty = e->start_qty;
            int ok = 1;

            for (int leg = 0; leg < n_legs - 1; ++leg)
            {
                int a = row[leg];
                int b = row[leg + 1];
                double ask = e->mat.ASK[matrix_idx(&e->mat, a, b)];
                if (!(ask > 0.0) || !isfinite(ask))
                {
                    ok = 0;
                    break;
                }
                qty = qty / ask;
            }
            if (!ok)
                continue;

            int last = row[n_legs - 1];
            int back = row[n_legs];
            double bid = e->mat.BID[matrix_idx(&e->mat, last, back)];
            if (!(bid > 0.0) || !isfinite(bid))
                continue;

            double fin = qty * bid;
            double pnl = fin - e->start_qty;
            if (!isfinite(pnl))
                continue;

            result_t r;
            r.route_id = route + 1;
            r.mid_i = 0;
            r.end_i = 0;
            r.final_base = fin;
            r.edge = (fin / e->start_qty) - 1.0;
            r.pnl = pnl;
            r.pct = (pnl / e->start_qty) * 100.0;
            r.ts_ns = ts;
            if (result_rb_t_push(&e->result_rb, &r))
            {
                e->results_emitted++;
            }
            else
            {
                e->results_dropped++;
            }
        }
    }
}

static void *engine_thread_main(void *p)
{
    engine_t *e = (engine_t *)p;

    while (atomic_load(&e->running))
    {
        tick_t t;
        int got = tick_rb_t_pop(&e->tick_rb, &t);
        if (!got)
        {
            struct timespec req;
            req.tv_sec = 0;
            req.tv_nsec = 200000; // 0.2 ms
            nanosleep(&req, NULL);
            continue;
        }

        int i0 = t.i_1b - 1;
        int j0 = t.j_1b - 1;
        matrix_update_pair(&e->mat, i0, j0, t.bid, t.ask);

        while (tick_rb_t_pop(&e->tick_rb, &t))
        {
            i0 = t.i_1b - 1;
            j0 = t.j_1b - 1;
            matrix_update_pair(&e->mat, i0, j0, t.bid, t.ask);
        }

        eval_all_routes(e);
    }
    return NULL;
}

// ---------- Public API ----------
static engine_t *engine_alloc_common(int n_ccy, int start_i_1b)
{
    if (n_ccy <= 1)
        return NULL;
    if (start_i_1b < 1 || start_i_1b > n_ccy)
        return NULL;

    engine_t *e = (engine_t *)calloc(1, sizeof(engine_t));
    if (!e)
        return NULL;

    e->n_ccy = n_ccy;
    e->start0 = start_i_1b - 1;
    e->start_qty = 100000.0;

    e->ticks_received  = 0;
    e->ticks_dropped   = 0;
    e->results_emitted = 0;
    e->results_dropped = 0;

    if (!matrix_init(&e->mat, n_ccy))
    {
        free(e);
        return NULL;
    }

    tick_rb_t_init(&e->tick_rb);
    result_rb_t_init(&e->result_rb);
    atomic_store(&e->running, 0);
    return e;
}

engine_t *engine_create_tri(int n_ccy, int start_i_1b,
                            const int *mid_end_rowmajor, int n_routes,
                            int one_based)
{
    engine_t *e = engine_alloc_common(n_ccy, start_i_1b);
    if (!e)
        return NULL;

    if (!routes_init_tri(&e->routes, mid_end_rowmajor, n_routes, one_based))
    {
        engine_destroy(e);
        return NULL;
    }
    return e;
}

engine_t *engine_create_cycle(int n_ccy, int start_i_1b,
                              const int *nodes_rowmajor, int n_routes, int n_cols,
                              int one_based)
{
    engine_t *e = engine_alloc_common(n_ccy, start_i_1b);
    if (!e)
        return NULL;

    if (!routes_init_cycle(&e->routes, nodes_rowmajor, n_routes, n_cols, one_based))
    {
        engine_destroy(e);
        return NULL;
    }
    return e;
}

void engine_destroy(engine_t *e)
{
    if (!e)
        return;
    engine_stop(e);
    routes_free(&e->routes);
    matrix_free(&e->mat);
    free(e);
}

int engine_start(engine_t *e)
{
    if (!e)
        return 0;

    int expected = 0;
    if (!atomic_compare_exchange_strong(&e->running, &expected, 1))
        return 1;

    if (pthread_create(&e->thread, NULL, engine_thread_main, e) != 0)
    {
        atomic_store(&e->running, 0); // viktig fix
        return 0;
    }
    return 1;
}

void engine_stop(engine_t *e)
{
    if (!e)
        return;
    if (atomic_exchange(&e->running, 0))
    {
        (void)pthread_join(e->thread, NULL);
    }
}

int engine_push_tick(engine_t *e, int i_1b, int j_1b, double bid, double ask)
{
    if (!e)
        return 0;

    tick_t t;
    t.i_1b = i_1b;
    t.j_1b = j_1b;
    t.bid = bid;
    t.ask = ask;
    t.ts_ns = ticks_now_ns();

    int ok = tick_rb_t_push(&e->tick_rb, &t);
    if (ok) {
        e->ticks_received++;
    } else {
        e->ticks_dropped++;
    }
    return ok;
}
int engine_pop_result(engine_t *e, result_t *out)
{
    if (!e || !out)
        return 0;
    return result_rb_t_pop(&e->result_rb, out);
}


==========================================================
üìÑ engine.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/engine.h
==========================================================
#pragma once
#include <stdint.h>
#include "ticks.h"
#include "results.h"

#ifdef __cplusplus
extern "C"
{
#endif

    typedef struct engine_t engine_t;

    // Constructors
    engine_t *engine_create_tri(int n_ccy, int start_i_1b,
                                const int *mid_end_rowmajor, int n_routes,
                                int one_based);

    engine_t *engine_create_cycle(int n_ccy, int start_i_1b,
                                  const int *nodes_rowmajor, int n_routes, int n_cols,
                                  int one_based);

    // Lifecycle
    void engine_destroy(engine_t *e);

    // Thread control
    int engine_start(engine_t *e);
    void engine_stop(engine_t *e);

    // Feed ticks
    int engine_push_tick(engine_t *e, int i_1b, int j_1b, double bid, double ask);

    // Pop results (non-blocking): returns 1 if popped, else 0
    int engine_pop_result(engine_t *e, result_t *out);

#ifdef __cplusplus
}
#endif


==========================================================
üìÑ matrix.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/matrix.c
==========================================================
#include "matrix.h"
#include <stdlib.h>
#include <string.h>

static void *aligned_malloc64(size_t bytes)
{
    void *p = NULL;
    // posix_memalign works well on macOS
    if (posix_memalign(&p, 64, bytes) != 0)
        return NULL;
    return p;
}

int matrix_init(matrix_t *m, int n)
{
    if (!m || n <= 1)
        return 0;
    m->n = n;

    size_t N = (size_t)n * (size_t)n;
    size_t bytes = N * sizeof(double);

    m->M = (double *)aligned_malloc64(bytes);
    m->BID = (double *)aligned_malloc64(bytes);
    m->ASK = (double *)aligned_malloc64(bytes);
    if (!m->M || !m->BID || !m->ASK)
    {
        matrix_free(m);
        return 0;
    }

    memset(m->M, 0, bytes);
    memset(m->BID, 0, bytes);
    memset(m->ASK, 0, bytes);
    return 1;
}

void matrix_free(matrix_t *m)
{
    if (!m)
        return;
    free(m->M);
    m->M = NULL;
    free(m->BID);
    m->BID = NULL;
    free(m->ASK);
    m->ASK = NULL;
    m->n = 0;
}


==========================================================
üìÑ matrix.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/matrix.h
==========================================================
#pragma once
#include <stddef.h>
#include <math.h>

#ifdef __cplusplus
extern "C"
{
#endif

    typedef struct matrix_t
    {
        int n;
        double *M;
        double *BID;
        double *ASK;
    } matrix_t;

    int matrix_init(matrix_t *m, int n);
    void matrix_free(matrix_t *m);

    static inline size_t matrix_idx(const matrix_t *m, int i0, int j0)
    {
        return (size_t)i0 * (size_t)m->n + (size_t)j0;
    }

    static inline void matrix_update_pair(matrix_t *m, int i0, int j0, double bid, double ask)
    {
        size_t k = matrix_idx(m, i0, j0);
        m->BID[k] = bid;
        m->ASK[k] = ask;

        if (bid > 0.0 && ask > 0.0)
        {
            double x = bid * ask;
            m->M[k] = (x > 0.0) ? sqrt(x) : 0.0;
        }
        else
        {
            m->M[k] = 0.0;
        }
    }

#ifdef __cplusplus
}
#endif


==========================================================
üìÑ results.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/results.h
==========================================================
#pragma once
#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif

    typedef struct result_t
    {
        int route_id; // 1-based
        int mid_i;    // 1-based (for tri routes; 0 if N-leg not representable)
        int end_i;    // 1-based (for tri routes; 0 if N-leg not representable)
        double edge;
        double final_base;
        double pnl;
        double pct;
        uint64_t ts_ns;
    } result_t;

#ifdef __cplusplus
}
#endif


==========================================================
üìÑ ringbuffer.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/ringbuffer.h
==========================================================
#pragma once
#include <stddef.h>
#include <stdatomic.h>

#ifdef __cplusplus
extern "C"
{
#endif

// SPSC ringbuffer (single-producer, single-consumer)
// Capacity is N, but usable slots are N-1 (classic ring).
#define RB_DEFINE(name, type, N)                                               \
    typedef struct name                                                        \
    {                                                                          \
        type buffer[(N)];                                                      \
        atomic_size_t head;                                                    \
        atomic_size_t tail;                                                    \
    } name;                                                                    \
                                                                               \
    static inline void name##_init(name *rb)                                   \
    {                                                                          \
        atomic_init(&rb->head, 0);                                             \
        atomic_init(&rb->tail, 0);                                             \
    }                                                                          \
                                                                               \
    static inline int name##_push(name *rb, const type *v)                     \
    {                                                                          \
        size_t h = atomic_load_explicit(&rb->head, memory_order_relaxed);      \
        size_t n = (h + 1) % (N);                                              \
        size_t t = atomic_load_explicit(&rb->tail, memory_order_acquire);      \
        if (n == t)                                                            \
            return 0;                                                          \
        rb->buffer[h] = *v;                                                    \
        atomic_store_explicit(&rb->head, n, memory_order_release);             \
        return 1;                                                              \
    }                                                                          \
                                                                               \
    static inline int name##_pop(name *rb, type *out)                          \
    {                                                                          \
        size_t t = atomic_load_explicit(&rb->tail, memory_order_relaxed);      \
        size_t h = atomic_load_explicit(&rb->head, memory_order_acquire);      \
        if (t == h)                                                            \
            return 0;                                                          \
        *out = rb->buffer[t];                                                  \
        atomic_store_explicit(&rb->tail, (t + 1) % (N), memory_order_release); \
        return 1;                                                              \
    }

#ifdef __cplusplus
}
#endif


==========================================================
üìÑ routes.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/routes.c
==========================================================
#include "routes.h"
#include <stdlib.h>
#include <string.h>

void routes_free(routes_t *r)
{
    if (!r)
        return;
    free(r->mid0);
    r->mid0 = NULL;
    free(r->end0);
    r->end0 = NULL;
    free(r->nodes0);
    r->nodes0 = NULL;
    r->n_routes = 0;
    r->n_cols = 0;
    r->kind = 0;
}

int routes_init_tri(routes_t *r, const int *input_mid_end, int n_routes, int one_based)
{
    if (!r || !input_mid_end || n_routes <= 0)
        return 0;
    memset(r, 0, sizeof(*r));
    r->kind = ROUTES_KIND_TRI;
    r->n_routes = n_routes;

    r->mid0 = (int *)malloc((size_t)n_routes * sizeof(int));
    r->end0 = (int *)malloc((size_t)n_routes * sizeof(int));
    if (!r->mid0 || !r->end0)
    {
        routes_free(r);
        return 0;
    }

    for (int k = 0; k < n_routes; ++k)
    {
        int mid = input_mid_end[2 * k + 0];
        int end = input_mid_end[2 * k + 1];
        if (one_based)
        {
            mid--;
            end--;
        }
        r->mid0[k] = mid;
        r->end0[k] = end;
    }
    return 1;
}

int routes_init_cycle(routes_t *r, const int *nodes, int n_routes, int n_cols, int one_based)
{
    if (!r || !nodes || n_routes <= 0 || n_cols < 2)
        return 0;
    memset(r, 0, sizeof(*r));
    r->kind = ROUTES_KIND_CYCLE;
    r->n_routes = n_routes;
    r->n_cols = n_cols;

    size_t L = (size_t)n_routes * (size_t)n_cols;
    r->nodes0 = (int *)malloc(L * sizeof(int));
    if (!r->nodes0)
    {
        routes_free(r);
        return 0;
    }

    for (size_t i = 0; i < L; ++i)
    {
        int v = nodes[i];
        if (one_based)
            v--;
        r->nodes0[i] = v;
    }
    return 1;
}


==========================================================
üìÑ routes.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/routes.h
==========================================================
#pragma once
#include <stddef.h>

#ifdef __cplusplus
extern "C"
{
#endif

    typedef enum routes_kind_t
    {
        ROUTES_KIND_TRI = 1,  // routes are (mid,end)
        ROUTES_KIND_CYCLE = 2 // general cycle nodes (N legs)
    } routes_kind_t;

    typedef struct routes_t
    {
        routes_kind_t kind;
        int n_routes;

        // TRI fast-path:
        int *mid0; // 0-based
        int *end0; // 0-based

        // General cycle:
        int n_cols;  // nodes per route row (>=2). legs = n_cols-1
        int *nodes0; // row-major, 0-based indices, length n_routes*n_cols
    } routes_t;

    void routes_free(routes_t *r);

    // Create TRI from mid/end row-major.
    // input_mid_end: length n_routes*2
    int routes_init_tri(routes_t *r, const int *input_mid_end, int n_routes, int one_based);

    // Create cycle from nodes row-major.
    // nodes: length n_routes*n_cols; columns = nodes per route (n_legs+1)
    // If one_based=1, converts to 0-based.
    int routes_init_cycle(routes_t *r, const int *nodes, int n_routes, int n_cols, int one_based);

#ifdef __cplusplus
}
#endif


==========================================================
üìÑ test_engine.py
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/test_engine.py
==========================================================
#!/usr/bin/env python3
# test_engine.py ‚Äî kj√∏r fra katalogen som inneholder engine_py.py og libengine_v4.dylib

from engine_py import Engine
import time
import os, sys

print("cwd:", os.getcwd())
print("engine_py exists:", os.path.exists(os.path.join(os.getcwd(), "engine_py.py")))
print("lib exists:", os.path.exists(os.path.join(os.getcwd(), "libengine_v4.dylib")))

try:
    eng = Engine(n_ccy=4, start_i_1b=1, routes_mid_end_1b=[(2,3)])
except Exception as e:
    print("FEIL ved opprettelse av Engine:", e)
    sys.exit(1)

started = eng.start()
print("started:", started)

# Push syntetiske ticks (bid, ask)
eng.push_tick(1, 2, 0.0, 1.1)   # start->mid : ask=1.1
eng.push_tick(2, 3, 0.0, 1.1)   # mid->end   : ask=1.1
eng.push_tick(3, 1, 1.25, 0.0)  # end->start : bid=1.25

time.sleep(0.05)   # gi motoren litt tid
print("poll:", eng.poll())

eng.stop()
eng.destroy()


==========================================================
üìÑ ticks.c
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/ticks.c
==========================================================
#include "ticks.h"

#if defined(__APPLE__)
#include <mach/mach_time.h>
uint64_t ticks_now_ns(void)
{
    static mach_timebase_info_data_t tb = {0, 0};
    if (tb.denom == 0)
        (void)mach_timebase_info(&tb);
    uint64_t t = mach_absolute_time();
    // ns = t * numer/denom
    return (t * (uint64_t)tb.numer) / (uint64_t)tb.denom;
}
#else
#include <time.h>
uint64_t ticks_now_ns(void)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec * 1000000000ull + (uint64_t)ts.tv_nsec;
}
#endif


==========================================================
üìÑ ticks.h
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/C++/ticks.h
==========================================================
#pragma once
#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif

    typedef struct tick_t
    {
        int i_1b;
        int j_1b;
        double bid;
        double ask;
        uint64_t ts_ns;
    } tick_t;

    uint64_t ticks_now_ns(void);

#ifdef __cplusplus
}
#endif



#########################
###   üöÄ RUN SCRIPT   ###
#########################


==========================================================
üìÑ run.R
PATH: /Users/sigurdberner/FX_ARBITRAGE_FINALE copy/run.R
==========================================================
# Run.R

# --- Libraries ---
suppressPackageStartupMessages({
  library(Rcpp); library(httr2); library(jsonlite)
  library(dplyr); library(lubridate); library(readr)
  library(curl);  library(rlang);     library(tidyr); library(dotenv)
})

# --- Reset debug state ---
suppressWarnings({
  options(error = NULL)
  debuggingState(FALSE)
  try(undebug(base::open.connection), silent = TRUE)
  try(undebug(base::readBin),        silent = TRUE)
  try(untrace(base::open.connection), silent = TRUE)
  try(untrace(base::readBin),         silent = TRUE)
})

# --- Project root ---
Sys.setenv(CURL_DNS_SERVERS = "1.1.1.1,8.8.8.8")
setwd("/Users/sigurdberner/FX_ARBITRAGE_FINALE copy")
ROOT <- "/Users/sigurdberner/FX_ARBITRAGE_FINALE copy"
readRenviron(file.path(ROOT, ".env"))

`%||%` <- function(x, y) if (is.null(x)) y else x

# --- Tuning knobs ---
options(
  arb.matrix_tol           = 1e-12,
  arb.K                    = 300L,
  arb.fee_pct              = 0,
  arb.assumed_slip_bps     = 0,
  arb.safety_buffer_bps    = 0,
  arb.k_slip               = 0,
  arb.rvbps_fallback_bps   = 0,
  arb.near_window_bps      = 0,
  arb.min_interval_ms      = 0L,
  arb.min_interval_fast_ms = 1L,
  arb.start_ccy            = "USD",
  arb.bankroll             = 100000,
  arb.bps_scale            = 1e4,
  arb.min_edge_bps         = 0L
)

# --- Load core files ---
source(file.path(ROOT, "R/core_runtime.R"))
source(file.path(ROOT, "R/DirectStream.R"))
source(file.path(ROOT, "R/Trading_Bot.R"))
source(file.path(ROOT, "R/Engine_Wrapper.R"))

# --- Load C++ engine ---
engine_load(file.path(ROOT, "C++", "build", "libengine_v4.dylib"))

message("‚úÖ All core scripts loaded.")

# --- Bootstrap ---
stopifnot(DS$has_auth())
cat("üöÄ Oppsett klart‚Ä¶\n")

all_instr <- DS$list_symbols()
STREAM_UNIVERSE <- (100L)

cat(sprintf("\nüì¶ Abonnerer p√• %d instrumenter:\n%s\n",
            length(STREAM_UNIVERSE),
            paste(STREAM_UNIVERSE, collapse = ", ")))

# --- Build state ---
state <- init_state(
  DS          = DS,
  instruments = STREAM_UNIVERSE,
  start_ccy   = getOption("arb.start_ccy")
)

# --------------------------------------------------------
# ‚≠ê‚≠ê‚≠ê INIT ENGINE EXACTLY HERE ‚≠ê‚≠ê‚≠ê
# --------------------------------------------------------
start_ccy <- getOption("arb.start_ccy")
engine_init(state, start_ccy)
# --------------------------------------------------------

# --- Tick handler ---
on_tick <- make_on_tick(state)


# =====================================================================
# üìä PRINT RESULTATER + BEN-FOR-BEN DEBUGGING
# =====================================================================
poll_and_print <- function(state) {
  res <- engine_poll(state$eng)
  
  if (is.null(res) || nrow(res) == 0) {
    cat("‚ùï Ingen ruter funnet i denne ticken\n")
    return(invisible())
  }
  
  cat("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n")
  cat("üìä TRI-ARBITRAGE RESULTATER (", nrow(res), " ruter )\n", sep="")
  
  for (k in seq_len(nrow(res))) {
    r <- res[k, ]
    
    cat(sprintf(
      "‚Ä¢ route_id=%d | mid=%s | end=%s | pnl=%.5f | edge=%.5f | pct=%.3f%% | ns=%s\n",
      r$route_id, r$mid, r$end, r$pnl, r$edge, r$pct*100, format(ns(), scientific = FALSE)
    ))
  }
}


# =====================================================================
# üîÑ WRAPPED TICK
# =====================================================================
wrapped_on_tick <- function(sym, bid, ask, time) {
  
  if (identical(sym, "HEARTBEAT")) return(invisible())
  
  on_tick(sym, bid, ask, time)
  
  poll_and_print(state)
}


# =====================================================================
# üî¥ START STREAM
# =====================================================================
cat("\nüî¥ Starter LIVE stream‚Ä¶ (Ctrl+C for √• stoppe)\n")

DS$stream_prices(
  instruments        = STREAM_UNIVERSE,
  on_tick            = wrapped_on_tick,
  include_heartbeats = TRUE,
  verbose            = TRUE,
  snapshot           = TRUE
)

cat("‚úÖ Ferdig.\n")








